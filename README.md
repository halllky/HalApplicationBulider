# Nijo Application Builder 【開発中 under development】
論理データモデルから一般的なエンタープライズ系業務アプリケーションのひな形を自動生成するツール。

---
目次 Table of contents

- [Nijo Application Builder 【開発中 under development】](#nijo-application-builder-開発中-under-development)
  - [概要図 Overview](#概要図-overview)
  - [使い方の詳細 Usage](#使い方の詳細-usage)
    - [1. 論理データモデルを定義する](#1-論理データモデルを定義する)
      - [基本的な考え方](#基本的な考え方)
      - [単一の子要素（Child）](#単一の子要素child)
      - [複数の子要素（Children）](#複数の子要素children)
      - [多態子要素（Variation）](#多態子要素variation)
      - [他集約への参照（Ref）](#他集約への参照ref)
    - [2. コード自動生成を実行する](#2-コード自動生成を実行する)
    - [3. 自動生成で賄えない機能を自前で実装する](#3-自動生成で賄えない機能を自前で実装する)
    - [その他](#その他)
      - [nijo.exe のその他の使い方](#nijoexe-のその他の使い方)
  - [デモ Demo](#デモ-demo)
  - [開発者向け情報 for Contributors](#開発者向け情報-for-contributors)
  - [このソフトウェアを作成した動機 Motivation](#このソフトウェアを作成した動機-motivation)
  - [License](#license)

---

## 概要図 Overview
このツールを使用してアプリケーションを作成するための大まかな流れは以下です。

1. [論理データモデルを定義する](#1-論理データモデルを定義する)
2. [コード自動生成を実行する](#2-コード自動生成を実行する)
3. [自動生成で賄えない機能を自前で実装する](#3-自動生成で賄えない機能を自前で実装する)

![概要図 overview](./README_files/README.drawio.svg)

## 使い方の詳細 Usage

### 1. 論理データモデルを定義する

このリポジトリのReleasesページから実行可能なバイナリファイルをダウンロードしてください。
解凍したディレクトリを控えておくか、解凍したディレクトリをpathに登録してください。
（ここでは `C:\your-installed-directory` に解凍したものとします）

---
ターミナルやコマンドプロンプトから以下を実行してください。MyProjectの名称は自由に設定してください。

```cmd
C:\your-installed-directory\nijo.exe create MyProject
```

注意点
- 上記のコマンドは内部で `dotnet` および `npm` のコマンドラインツールを使用しています。それぞれMicrosoftおよびNode.jsの公式サイトから入手し、パスを通して使える状態にしてください。
- 上記のコマンドは `npm ci` を実行し、依存するパッケージのダウンロードを行います。ネットワークに接続された環境で実行してください。

---

作成されたディレクトリの中に `nijo.xml` という名前のファイルがあります。これをテキストエディタで編集し、あなたのアプリケーションで取り扱うデータの構造を定義してください。

**具体的・詳細な指定方法は [自動テストのXML](./Nijo.IntegrationTest/DataPatterns/) を参照してください。**
以下では基本的な考え方のみを説明します。

---
#### 基本的な考え方
**登録・更新・削除されるデータのまとまり**ごとにデータ構造を定義してください。
なおこのプロジェクトでは、このデータのまとまりを「集約（Aggregate）」と呼称しています。

そのデータ構造がもつことのできる子孫（子要素、入れ子構造）の種類には以下の3種類があります。

#### 単一の子要素（Child）
親1件に対する1件の入れ子データ。
具体的な設定方法はユニットテストのXML [003_Childのみ.xml](./Nijo.IntegrationTest/DataPatterns/003_Childのみ.xml) を参照してください。

例：「取引先」データの構造
- 取引先ID
- 取引先名
- **宛先** ← これがChild
  - 郵便番号
  - 住所
  - 電話番号

#### 複数の子要素（Children）
親1件に対する複数件の入れ子データ。
具体的な設定方法はユニットテストのXML [002_Childrenのみ.xml](./Nijo.IntegrationTest/DataPatterns/002_Childrenのみ.xml) を参照してください。

例：「発注」データの構造
- 発注番号
- 発注者名
- 発注日
- **明細** ← これがChildren
  - 連番
  - 商品名
  - 個数
  - 希望納品日

#### 多態子要素（Variation）
親1件に対する1件の入れ子データ、ただし異なるデータ構造をもつ複数のバリエーションから1つを選択するもの。
具体的な設定方法はユニットテストのXML [004_Variationのみ.xml](./Nijo.IntegrationTest/DataPatterns/004_Variationのみ.xml) を参照してください。

例：「旅費申請」データの構造
- 申請番号
- 申請者名
- 申請日
- **内訳** ← これがVariation（宿泊費または交通費のうちどちらかが択一で選択される）
  - **宿泊費**
    - 日程
    - 合計金額
    - 宿泊先名
  - **交通費**
    - 移動日
    - 区間
    - 片道金額
    - 片道か往復か

---
また、登録・更新・削除されるタイミングが異なる別のデータへの参照を定義することができます。

#### 他集約への参照（Ref）
登録・更新・削除されるタイミングが異なる別のデータへの参照。
具体的な設定方法はユニットテストのXML [001_Refのみ.xml](./Nijo.IntegrationTest/DataPatterns/001_Refのみ.xml) を参照してください。

例：
- 受注
  - **受注番号**
  - 明細
    - **受注明細番号**
    - 商品名
    - 個数
- 出荷指示
  - 出荷予定日
  - 出荷担当者名
  - 明細
    - **受注明細** ← これがRef。受注番号と受注明細番号の複合キーをもつ
    - 備考

### 2. コード自動生成を実行する
上記で作成したデータモデルでコード自動生成を実行し、動作確認を開始するため、ターミナルから以下のコマンドを実行してください。

```cmd
cd <nijo.xmlがあるディレクトリ>
C:\your-installed-directory\nijo.exe debug
```

動作確認を行わず、コードの自動生成のみを実行する場合は以下のコマンド。

```cmd
cd <nijo.xmlがあるディレクトリ>
C:\your-installed-directory\nijo.exe update
```

### 3. 自動生成で賄えない機能を自前で実装する
- 自動生成されるソースを編集する
  - 執筆中
- 自動生成された後のソースを編集する
  - ASP.NET Core Web API
    - `__AutoGenerated` フォルダの中身は編集しないこと！
      - このディレクトリの中はコード自動生成のたびに洗い替えられるため
    - `Program.cs`
      - 執筆中
    - `OverridedApplicationService.cs`
      - 執筆中
    - DbContext
      - 執筆中
  - React
    - `src/__autoGenerated` フォルダの中身は編集しないこと！
      - このディレクトリの中はコード自動生成のたびに洗い替えられるため
    - `App.tsx`
      - 執筆中

### その他
#### nijo.exe のその他の使い方
**執筆中**

## デモ Demo
- このリポジトリをクローンしてください。
- ユニットテストプロジェクト `Nijo.IntegrationTest` で様々なパターンのデータ構造定義をテストしています。「コンパイルエラーチェック」という名前のテストがあるので、閲覧したいデータ構造定義のテストを実行し、生成されたプロジェクトで実物の動作を確認してください。
  - どのようなパターンがあるかは [こちら](./Nijo.IntegrationTest/DataPatterns/) を参照してください。
  - ユニットテストの実行方法はNUnitの通常の実行方法に従ってください。
    1. Visual Studio のテストエクスプローラーから実行する（開発者はこちらの方法で実行しています）
    2. `dotnet test --filter "コンパイルエラーチェック(000_単純な集約.xml)"` のようにコマンドラインから実行する
- 上記テストの実行に成功した場合、 `/自動テストで作成されたプロジェクト` ディレクトリにプロジェクトが生成されます。
- プロジェクトのルートディレクトリ（ `nijo.xml` があるディレクトリ）でターミナルやコマンドプロンプトを開き、以下のコマンドを実行してください。

```cmd
C:\your-installed-directory\nijo.exe debug
```

確認方法
- 作成されたWebサイトの動作確認
  - localhostで実行されます。自動的にブラウザが表示されますが、ポートなどの詳細は以下を参照してください。
  - クライアントサイド（React SPA）のポート等は `/自動テストで作成されたプロジェクト/react/vite.config.ts` で指定されています。詳細な設定方法はViteの公式を参照してください。
  - サーバーサイド（ASP.NET Core Web API）のポート等は `/自動テストで作成されたプロジェクト/webapi/Properties/launchSettings.json` で指定されています。
  - サーバーサイドのAPIはクライアントサイドから呼ばれる形で実行されるため通常意識する必要はありませんが、これを直接実行したい場合、実行中のlocalhostでswaggerが展開されているので、そちらを参照してください。
- DB定義やデータの確認
  - このWebサイトで登録されたデータは、プロジェクトのルートディレクトリにある、拡張子が `sqlite3` のファイルに格納されています。このファイルの開き方はSQLiteの公式を参照してください。
- 自動生成されたソースコードの内容の確認
  - サーバーサイドの自動生成ソースは `/自動テストで作成されたプロジェクト/webapi/__AutoGenerated/` に展開されます。
  - クライアントサイドの自動生成ソースは `/自動テストで作成されたプロジェクト/react/src/__autoGenerated/` に展開されます。

## 開発者向け情報 for Contributors
- デバッグ手順
  - 執筆中
- リリース手順
  - 執筆中

## このソフトウェアを作成した動機 Motivation
- 画面からDBまでを一気通貫でカバーしてくれるちょうどよいライブラリ・フレームワークが欲しかった。
- CRUD機能のうちCUDは自動生成する効果が大きいと感じていた。
  - データの形が違うだけで気を付けなければいけないポイントはだいたいいつも同じ（キー重複の考慮、同時編集や排他制御、更新データ中に配列がある場合の実装の大変さ、二重登録の考慮、トランザクションの切り方、など）
  - その割には品質が低い場合のシステム全体に及ぼす実害が参照系処理に比べてとても大きい
  - システムの主要なデータではない補助的なデータ（いわゆるトランザクションデータに対するマスタデータのこと）について、機能要件が緩くなりがち（登録更新さえできればUIは割とどうでもいい）な割に上記の通り実装が大変なので、ここが自動生成されるととても助かる
- データモデル駆動の要件定義のため。
  - ウォーターフォール開発の要件定義フェーズにおいて、チーム内でデータモデルの議論を軸にして検討を進めたいことがよくある。そこではメンバー間で実際に動くデータを見つつ認識共有しながら進まないと議論が空中戦になるのだが、そのためにはデータモデルのたたき台を考えてから実際に動くデータができるまでを数分程度で実現できるツールが必要だった。
- 上記のような要件を満たしつつ、通常のスクラッチ開発と同レベルの柔軟性をもったツールが欲しかった
  - ネストされた子要素、伝票の明細など子要素の配列、多態性をもった子要素、他のデータへの参照、といった複雑なデータ構造を定義できてほしい
  - 複雑なデータについてパフォーマンスを落とさず高速なクエリを発行するためにはCQRSや生SQLの実装ができるようになっていてほしい
  - 日次業務のオペレーションに耐えうる画面、現行の業務フローに合致した画面、など厳しい要件を満たすためには画面のソースをゼロから組み上げられるようになっていてほしい
- オンプレにしようと思えばオンプレにもできるアーキテクチャ
  - いわゆるエンタープライズ系システム・基幹寄りのシステムは、寿命が長いのでフルマネージドであっておきたい
  - クラウド型のSaaSは提供事業者の意思次第でいつでも使えなくなりうる

## License
This software is released under the MIT License. see LICENSE.txt.
