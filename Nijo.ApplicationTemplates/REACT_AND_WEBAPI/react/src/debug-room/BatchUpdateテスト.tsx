import React, { useCallback, useEffect, useMemo, useRef } from 'react'
import { useFieldArray } from 'react-hook-form'
import { PanelGroup, Panel, PanelResizeHandle } from 'react-resizable-panels'
import * as Collection from '../__autoGenerated/collection'
import * as Input from '../__autoGenerated/input'
import * as Util from '../__autoGenerated/util'

import "../__autoGenerated/nijo-default-style.css"


export default function () {
  return (
    <Util.BatchUpdateContextProvider>
      <Util.MsgContextProvider>
        <Page />
      </Util.MsgContextProvider>
    </Util.BatchUpdateContextProvider>
  )
}

const Page = () => {

  const { list, loadItem, createNewItem, markToDelete, resetChanges, saveLocal } = Util.useLocalRepository()
  const { reset, control } = Util.useFormEx<TestDataCollection>({ defaultValues: {} })
  const { fields, append, update, remove } = useFieldArray({ name: 'items', control })
  const dtRef = useRef<Collection.DataTableRef<TestData>>(null)

  // デバッグ用
  const handleReset = useCallback(async () => {
    const initialDummyData = createDefaultData()
    reset(initialDummyData)
    for (const item of initialDummyData.items) {
      await createNewItem(DATA_TYPE_KEY, item)
    }
  }, [reset, resetChanges, createNewItem])

  // 初期表示時データ読み込み
  useEffect(() => {
    (async () => {
      // TODO: 1件ずつ読み込んでしまっている
      // TODO: データ型の変換に隙がある
      const items: TestData[] = []
      for (const keyname of list) {
        const stored = await loadItem(keyname.dataTypeKey, keyname.itemKey)
        if (!stored) continue
        items.push(JSON.parse(stored.contentsJson) as TestData)
      }
      reset({ items })
    })()
  }, [list, loadItem, reset])

  // 一時保存
  const handleSave = useCallback(async () => {
    // TODO: 1件ずつ保存してしまっている
    // TODO: RHF側でadd/modify/deleteの区別を持っていない
    for (const item of fields) {

      await saveLocal({ changeType, contentsJson, dataTypeKey, itemKey, itemName })
    }
  }, [fields, saveLocal])

  // データ操作
  const handleAdd: React.MouseEventHandler<HTMLButtonElement> = useCallback(async e => {
    // - データ初期化を呼び側でやるのは仕方ないか...
    // - RHFの操作とLocalRepositoryの操作が別々なのはむしろこの方がやりやすいかも？
    const newItem: TestData = {}
    append(newItem)
    const newItemId = await createNewItem<TestData>(DATA_TYPE_KEY, newItem)
    // TODO: ↑ここで生成したIDがどこにも保持されない
  }, [createNewItem, append])

  const handleRemove: React.MouseEventHandler<HTMLButtonElement> = useCallback(e => {
    if (!dtRef.current) return
    for (const index of dtRef.current.getSelectedIndexes().reverse()) {
      const item = fields[index]
      remove(index)
      markToDelete<TestData>(item)
    }
  }, [fields, markToDelete, remove])

  return (
    <PanelGroup
      direction="horizontal"
      className="w-full h-full"
      style={{ fontFamily: '"Arial", "BIZ UDゴシック"', fontSize: 14 }}
    >
      <Panel defaultSize={20}>
        <Collection.DataTable
          data={list}
          columns={LIST_COLS}
          className="h-full"
        />
      </Panel>

      <PanelResizeHandle className="w-4" />

      <Panel className="flex flex-col">
        <div className="flex gap-2 justify-start">
          <Input.Button onClick={handleAdd}>一時保存</Input.Button>
          <div className="basis-4"></div>
          <Input.Button onClick={handleAdd}>追加</Input.Button>
          <Input.Button onClick={handleRemove}>削除</Input.Button>
          <div className="flex-1"></div>
          <Input.Button onClick={handleReset}>初期化</Input.Button>
        </div>
        <Collection.DataTable
          ref={dtRef}
          data={fields}
          columns={CONTENTS_COLS}
          onChangeRow={update}
          className="flex-1"
        />
        <Util.InlineMessageList />
        <Util.Toast />
      </Panel>
    </PanelGroup>
  )
}

type TestDataCollection = {
  items: TestData[]
}
type TestData = {
  key?: string
  name?: string
  numValue?: number
}

const LIST_COLS: Collection.ColumnDefEx<Util.TreeNode<Util.ContextItem>>[] = [
  { id: 'col0', header: '', accessorFn: x => x.item.changeType },
  { id: 'col1', header: '　', accessorFn: x => x.item.itemName },
]
const CONTENTS_COLS: Collection.ColumnDefEx<Util.TreeNode<TestData>>[] = [
  { id: 'key', header: 'key', accessorFn: x => x.item.key, cellEditor: Input.Word },
  { id: 'name', header: '名前', accessorFn: x => x.item.name, cellEditor: Input.Word },
  { id: 'numValue', header: '数値', accessorFn: x => x.item.numValue, cellEditor: Input.Num },
]

const DATA_TYPE_KEY = 'TEST-DATA-20240204'
function createDefaultData(): TestDataCollection {
  const items: TestData[] = [
    { key: '001', name: 'データ01', numValue: 1.00 },
    { key: '002', name: 'データ02', numValue: 2.00 },
    { key: '003', name: 'データ03', numValue: 3.00 },
    { key: '004', name: 'データ04', numValue: 4.00 },
  ]
  return { items }
}
