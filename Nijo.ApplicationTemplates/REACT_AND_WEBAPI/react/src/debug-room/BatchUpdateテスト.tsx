import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react'
import { useFieldArray } from 'react-hook-form'
import { PanelGroup, Panel, PanelResizeHandle } from 'react-resizable-panels'
import * as Collection from '../__autoGenerated/collection'
import * as Input from '../__autoGenerated/input'
import * as Util from '../__autoGenerated/util'

import "../__autoGenerated/nijo-default-style.css"


export default function () {
  return (
    <Util.LocalRepositoryContextProvider>
      <Util.MsgContextProvider>
        <Page />
      </Util.MsgContextProvider>
    </Util.LocalRepositoryContextProvider>
  )
}

const Page = () => {

  // ローカルリポジトリのデータ一覧
  const {
    changes,
    ready: changeListIsReady,
  } = Util.useLocalRepositoryChangeList()

  // MultiView
  const {
    ready: multiViewIsReady,
    loadAll,
    loadOne,
    getLocalRepositoryState,
    addToLocalRepository,
    updateLocalRepositoryItem,
    deleteLocalRepositoryItem,
    commit,
  } = Util.useLocalRepository(REPOS_SETTING)

  const { control, reset } = Util.useFormEx<{ items: Util.LocalRepositoryStateAndKeyAndItem<TestData>[] }>({})
  const { fields, append, update, remove } = useFieldArray({ name: 'items', control })
  const [, dispatchMsg] = Util.useMsgContext()
  const dtRef = useRef<Collection.DataTableRef<Util.LocalRepositoryStateAndKeyAndItem<TestData>>>(null)

  useEffect(() => {
    if (multiViewIsReady) {
      // (async () => {
      //   const items = [...inmemoryRemoteRepos].map(([, item]) => ({ ...item }))
      //   const state = await getLocalRepositoryState()
      //   // TODO:
      //   // - リモートとローカルのマージ
      //   // - itemKeyの状態遷移をちゃんと考える。
      //   //   特にstateが*や-になる瞬間
      // })()
      loadAll().then(items => {
        reset({ items })
      })
    }
  }, [getLocalRepositoryState, reset, multiViewIsReady])

  const handleAdd: React.MouseEventHandler<HTMLButtonElement> = useCallback(async () => {
    const newItem: TestData = { name: '新規データ' }
    const added = await addToLocalRepository(newItem)
    append(added)
  }, [append, addToLocalRepository])

  const handleUpdateRow = useCallback(async (index: number, row: Util.LocalRepositoryStateAndKeyAndItem<TestData>) => {
    const updated = await updateLocalRepositoryItem(row.itemKey, row.item)
    update(index, updated)
  }, [update, updateLocalRepositoryItem])

  const handleRemove: React.MouseEventHandler<HTMLButtonElement> = useCallback(async () => {
    if (!dtRef.current) return
    // TODO: itemとindexまとめてほしい
    const items = dtRef.current.getSelectedItems()
    const indexes = dtRef.current.getSelectedIndexes()
    const deleted: number[] = []
    for (let i = 0; i < indexes.length; i++) {
      const { itemKey, item } = items[i]
      const { remains } = await deleteLocalRepositoryItem(itemKey, item)
      if (!remains) deleted.push(indexes[i])
    }
    remove(deleted)
  }, [remove, deleteLocalRepositoryItem])

  const handleReload = useCallback(async () => {
    const items = await loadAll()
    reset({ items })
  }, [loadAll, reset])

  const handleCreateDummy = useCallback(async () => {
    const initialDummyData = createDefaultData()
    for (const item of initialDummyData.items) {
      const { itemKey, state } = await addToLocalRepository(item)
      append({ item, itemKey, state })
    }
  }, [append, addToLocalRepository])

  // デバッグ用リモートリポジトリ
  const [inmemoryRemoteRepos, setInmemoryRemoteRepos] = useState<Map<string, TestData>>(() => new Map())
  const handleSave = useCallback(async () => {
    const local = await loadAll()
    const remote = new Map(inmemoryRemoteRepos)
    const removeFromDataTable = new Set<number>()

    for (const item of local) {
      if (!item.item.key) continue
      if (item.state === '+') {
        if (remote.has(item.item.key)) {
          dispatchMsg(msg => msg.error(`キー重複: ${item.item.key}`))
          continue
        }
        remote.set(item.item.key, item.item)
        await commit(item.itemKey)

      } else if (item.state === '*') {
        if (!remote.has(item.item.key)) {
          console.log(item.itemKey, item.state)
          dispatchMsg(msg => msg.error(`更新対象なし: ${item.item.key}`))
          continue
        }
        remote.set(item.item.key, item.item)
        await commit(item.itemKey)

      } else if (item.state === '-') {
        if (!remote.has(item.item.key)) {
          dispatchMsg(msg => msg.error(`削除対象なし: ${item.item.key}`))
          continue
        }
        remote.delete(item.item.key)
        await commit(item.itemKey)
        removeFromDataTable.add(fields.findIndex(x => x.item.key === item.item.key))
      }
    }
    setInmemoryRemoteRepos(remote)
    remove([...removeFromDataTable])
    dispatchMsg(msg => msg.info('保存しました。'))
  }, [loadAll, dispatchMsg, inmemoryRemoteRepos, fields, remove])

  const handleLogRemote = useCallback(() => {
    console.table([...inmemoryRemoteRepos.values()])
  }, [inmemoryRemoteRepos])

  return (
    <PanelGroup
      direction="horizontal"
      className="w-full h-full"
      style={{ fontFamily: '"Arial", "BIZ UDゴシック"', fontSize: 14 }}
    >
      <Panel defaultSize={20}>
        <Collection.DataTable
          data={changes}
          columns={LIST_COLS}
          className="h-full"
        />
      </Panel>

      <PanelResizeHandle className="w-4" />

      <Panel className="flex flex-col">
        <div className="flex gap-2 justify-start">
          <Input.Button onClick={handleSave}>保存</Input.Button>
          <Input.Button onClick={handleLogRemote}>(REMOTE)</Input.Button>
          <div className="basis-4"></div>
          <Input.Button onClick={handleAdd}>追加</Input.Button>
          <Input.Button onClick={handleRemove}>削除</Input.Button>
          <div className="flex-1"></div>
          <Input.Button onClick={handleReload}>再読込</Input.Button>
          <Input.Button onClick={handleCreateDummy}>ダミー</Input.Button>
        </div>
        <Collection.DataTable
          ref={dtRef}
          data={fields}
          columns={CONTENTS_COLS}
          onChangeRow={handleUpdateRow}
          className="flex-1"
        />
        <Util.InlineMessageList />
        <Util.Toast />
      </Panel>
    </PanelGroup>
  )
}

type TestDataCollection = {
  items: TestData[]
}
type TestData = {
  key?: string
  name?: string
  numValue?: number
}

const LIST_COLS: Collection.ColumnDefEx<Util.TreeNode<Util.LocalRepositoryItemListItem>>[] = [
  { id: 'col0', header: '　', accessorFn: x => x.item.state },
  { id: 'col1', header: '　', accessorFn: x => x.item.itemName },
]
const CONTENTS_COLS: Collection.ColumnDefEx<Util.TreeNode<Util.LocalRepositoryStateAndKeyAndItem<TestData>>>[] = [
  { id: 'state', header: '', accessorFn: x => x.item.state, size: 12 },
  { id: 'key', header: 'key', accessorFn: x => x.item.item.key, setValue: (x, v) => x.item.item.key = v, cellEditor: Input.Word },
  { id: 'name', header: '名前', accessorFn: x => x.item.item.name, setValue: (x, v) => x.item.item.name = v, cellEditor: Input.Word },
  { id: 'numValue', header: '数値', accessorFn: x => x.item.item.numValue, setValue: (x, v) => x.item.item.numValue = v, cellEditor: Input.Num },
]

const REPOS_SETTING: Util.LocalRepositoryArgs<TestData> = {
  dataTypeKey: 'TEST-DATA-20240204',
  serialize: data => JSON.stringify(data),
  deserialize: str => JSON.parse(str),
  getItemKey: data => data.key ?? '',
  getItemName: data => data.name ?? '',
}

function createDefaultData(): TestDataCollection {
  const items: TestData[] = [
    { key: '001', name: 'データ01', numValue: 1.00 },
    { key: '002', name: 'データ02', numValue: 2.00 },
    { key: '003', name: 'データ03', numValue: 3.00 },
    { key: '004', name: 'データ04', numValue: 4.00 },
  ]
  return { items }
}
