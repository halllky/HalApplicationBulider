using HalApplicationBuilder.CodeRendering;
using HalApplicationBuilder.CodeRendering.EFCore;
using HalApplicationBuilder.CodeRendering.WebClient;
using HalApplicationBuilder.Core;
using HalApplicationBuilder.DotnetEx;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Xml.Linq;

namespace HalApplicationBuilder
{
    public partial class HalappProject {

        private protected const string HALAPP_XML_NAME = "halapp.xml";
        private protected const string REACT_DIR = "client";
        internal const string REACT_PAGE_DIR = "pages";
        private protected const string HALAPP_DLL_COPY_TARGET = "halapp-resource";

        /// <summary>
        /// 新しいhalappプロジェクトを作成します。
        /// </summary>
        /// <param name="applicationName">アプリケーション名</param>
        /// <param name="verbose">ログの詳細出力を行うかどうか</param>
        /// <returns>作成されたプロジェクトを表すオブジェクト</returns>
        public static HalappProject Create(string projectRootDir, string? applicationName, bool keepTempIferror, CancellationToken? cancellationToken = null, TextWriter? log = null, bool verbose = false) {

            if (string.IsNullOrWhiteSpace(applicationName))
                throw new InvalidOperationException($"Please specify name of new application. example 'halapp create my-new-app'");

            if (Path.GetInvalidFileNameChars().Any(applicationName.Contains))
                throw new InvalidOperationException($"'{applicationName}' contains invalid characters for a file name.");

            if (Directory.Exists(projectRootDir))
                throw new InvalidOperationException($"'{projectRootDir}' is already exists.");

            var tempDir = keepTempIferror
                ? projectRootDir
                : Directory.CreateTempSubdirectory("halapp.temp.").FullName;

            var error = false;
            try {
                var tempProject = new HalappProject2(tempDir, log, verbose);

                Directory.CreateDirectory(tempDir);

                tempProject.EnsureCreateHalappXml(applicationName);

                tempProject.DotnetNew();

                tempProject.EditProgramCs();
                tempProject.UpdateAutoGeneratedCode();

                tempProject.AddNugetPackages();
                tempProject.AddReferenceToHalappDll();

                tempProject.EnsureCreateDatabase();

                // git initial commit
                var cmd = new Terminal {
                    WorkingDirectory = tempDir,
                    CancellationToken = cancellationToken,
                    Verbose = verbose,
                };
                cmd.Exec("git", "init");
                cmd.Exec("git", "add", ".");
                cmd.Exec("git", "commit", "-m", "init");

                // ここまでの処理がすべて成功したら一時ディレクトリを本来のディレクトリ名に変更
                if (tempDir != projectRootDir) {
                    if (Directory.Exists(projectRootDir)) throw new InvalidOperationException($"プロジェクトディレクトリを {projectRootDir} に移動できません。");
                    Directory.Move(tempDir, projectRootDir);
                }

                log?.WriteLine("プロジェクト作成完了");

                return new HalappProject2(projectRootDir, log, verbose);

            } catch {
                error = true;
                throw;

            } finally {
                if (tempDir != projectRootDir && Directory.Exists(tempDir) && (keepTempIferror == false || error == false)) {
                    try {
                        Directory.Delete(tempDir, true);
                    } catch (Exception ex) {
                        log?.WriteLine(new Exception("Failure to delete temp directory.", ex).ToString());
                    }
                }
            }
        }
        /// <summary>
        /// 既存のhalappプロジェクトを開きます。
        /// </summary>
        /// <param name="path">プロジェクトルートディレクトリの絶対パス</param>
        /// <returns>作成されたプロジェクトを表すオブジェクト</returns>
        public static HalappProject Open(string? path, TextWriter? log = null, bool verbose = false) {
            if (string.IsNullOrWhiteSpace(path))
                return new HalappProject2(Directory.GetCurrentDirectory(), log, verbose);
            else if (Path.IsPathRooted(path))
                return new HalappProject2(path, log, verbose);
            else
                return new HalappProject2(Path.Combine(Directory.GetCurrentDirectory(), path), log, verbose);
        }

        private protected HalappProject(string projetctRoot, TextWriter? log, bool verbose) {
            if (string.IsNullOrWhiteSpace(projetctRoot))
                throw new ArgumentException($"'{nameof(projetctRoot)}' is required.");

            ProjectRoot = projetctRoot;
            _log = log;
            _verbose = verbose;
        }

        protected readonly bool _verbose;
        protected readonly TextWriter? _log;

        public string ProjectRoot { get; }
        public Config ReadConfig() {
            var xmlFullPath = GetAggregateSchemaPath();
            using var stream = IO.OpenFileWithRetry(xmlFullPath);
            using var reader = new StreamReader(stream);
            var xmlContent = reader.ReadToEnd();
            var xDocument = XDocument.Parse(xmlContent);
            var config = Config.FromXml(xDocument);
            return config;
        }

        public string GetAggregateSchemaPath() {
            return Path.Combine(ProjectRoot, HALAPP_XML_NAME);
        }

        /// <summary>
        /// このディレクトリがhalappのものとして妥当なものかどうかを検査します。
        /// </summary>
        public bool IsValidDirectory() {
            var errors = new List<string>();

            if (Path.GetInvalidPathChars().Any(ProjectRoot.Contains))
                errors.Add($"Invalid path format: '{ProjectRoot}'");

            if (!Directory.Exists(ProjectRoot))
                errors.Add($"Directory '{ProjectRoot}' is not exist.");

            var halappXml = GetAggregateSchemaPath();
            if (!File.Exists(halappXml))
                errors.Add($"'{halappXml}' is not found.");

            if (_log != null) {
                foreach (var error in errors) _log.WriteLine(error);
            }
            return errors.Count == 0;
        }

        /// <summary>
        /// dotnet new コマンドを実行します。
        /// </summary>
        internal HalappProject DotnetNew() {
            _log?.WriteLine($"プロジェクトを作成します。");

            var config = ReadConfig();
            var cmd = new Terminal {
                WorkingDirectory = ProjectRoot,
                Verbose = _verbose,
            };

            cmd.Exec("dotnet", "new", "webapi", "--output", ".", "--name", config.ApplicationName);

            // Create .gitignore file
            cmd.Exec("dotnet", "new", "gitignore");
            var filename = Path.Combine(ProjectRoot, ".gitignore");
            var gitignore = File.ReadAllLines(filename).ToList();
            gitignore.Insert(0, "# HalApplicationBuilder");
            gitignore.Insert(1, $"/{HALAPP_DLL_COPY_TARGET}/*");
            File.WriteAllLines(filename, gitignore);

            return this;
        }
        /// <summary>
        /// Program.cs ファイルを編集し、必要なソースコードを追記します。
        /// </summary>
        /// <returns></returns>
        internal HalappProject EditProgramCs() {
            _log?.WriteLine($"Program.cs ファイルを書き換えます。");
            var programCsPath = Path.Combine(ProjectRoot, "Program.cs");
            var lines = File.ReadAllLines(programCsPath).ToList();
            var regex1 = new Regex(@"^.*[a-zA-Z]+ builder = .+;$");
            var position1 = lines.FindIndex(regex1.IsMatch);
            if (position1 == -1) throw new InvalidOperationException("Program.cs の中にIServiceCollectionを持つオブジェクトを初期化する行が見つかりません。");
            lines.InsertRange(position1 + 1, new[] {
                    $"",
                    $"/* HalApplicationBuilder によって自動生成されたコード ここから */",
                    $"var runtimeRootDir = System.IO.Directory.GetCurrentDirectory();",
                    $"HalApplicationBuilder.Runtime.HalAppDefaultConfigurer.Configure(builder.Services, runtimeRootDir);",
                    $"// HTMLのエンコーディングをUTF-8にする(日本語のHTMLエンコード防止)",
                    $"builder.Services.Configure<Microsoft.Extensions.WebEncoders.WebEncoderOptions>(options => {{",
                    $"    options.TextEncoderSettings = new System.Text.Encodings.Web.TextEncoderSettings(System.Text.Unicode.UnicodeRanges.All);",
                    $"}});",
                    $"// npm start で実行されるポートがASP.NETのそれと別なので",
                    $"builder.Services.AddCors(options => {{",
                    $"    options.AddDefaultPolicy(builder => {{",
                    $"        builder.AllowAnyOrigin()",
                    $"            .AllowAnyMethod()",
                    $"            .AllowAnyHeader();",
                    $"    }});",
                    $"}});",
                    $"/* HalApplicationBuilder によって自動生成されたコード ここまで */",
                    $"",
                });

            var regex2 = new Regex(@"^.*[a-zA-Z]+ app = .+;$");
            var position2 = lines.FindIndex(regex2.IsMatch);
            if (position2 == -1) throw new InvalidOperationException("Program.cs の中にappオブジェクトを初期化する行が見つかりません。");
            lines.InsertRange(position2 + 1, new[] {
                    $"",
                    $"/* HalApplicationBuilder によって自動生成されたコード ここから */",
                    $"// 前述AddCorsの設定をするならこちらも必要",
                    $"app.UseCors();",
                    $"/* HalApplicationBuilder によって自動生成されたコード ここまで */",
                    $"",
                });
            File.WriteAllLines(programCsPath, lines);

            return this;
        }
        /// <summary>
        /// コードの自動生成を行います。
        /// </summary>
        /// <param name="log">ログ出力先</param>
        public virtual HalappProject UpdateAutoGeneratedCode() {
            throw new NotImplementedException();
        }
        /// <summary>
        /// 必要なNuGetパッケージを参照に加えます。
        /// </summary>
        internal HalappProject AddNugetPackages() {
            var cmd = new Terminal {
                WorkingDirectory = ProjectRoot,
                Verbose = _verbose,
            };

            _log?.WriteLine($"Microsoft.EntityFrameworkCore パッケージへの参照を追加します。");
            cmd.Exec("dotnet", "add", "package", "Microsoft.EntityFrameworkCore");

            _log?.WriteLine($"Microsoft.EntityFrameworkCore.Proxies パッケージへの参照を追加します。");
            cmd.Exec("dotnet", "add", "package", "Microsoft.EntityFrameworkCore.Proxies");

            _log?.WriteLine($"Microsoft.EntityFrameworkCore.Design パッケージへの参照を追加します。"); // migration add に必要
            cmd.Exec("dotnet", "add", "package", "Microsoft.EntityFrameworkCore.Design");

            _log?.WriteLine($"Microsoft.EntityFrameworkCore.Sqlite パッケージへの参照を追加します。");
            cmd.Exec("dotnet", "add", "package", "Microsoft.EntityFrameworkCore.Sqlite");

            return this;
        }
        /// <summary>
        /// halapp.dllとその依存先をプロジェクトディレクトリにコピーする。実行時にRuntimeContextを参照しているため
        /// </summary>
        internal virtual HalappProject AddReferenceToHalappDll() {
            _log?.WriteLine($"halapp.dll を参照に追加します。");

            // dllのコピー
            var halappDirCopySource = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)!;
            var halappDirCopyDist = Path.Combine(ProjectRoot, HALAPP_DLL_COPY_TARGET);
            IO.CopyDirectory(halappDirCopySource, halappDirCopyDist, deleteOnlyDist: true);

            // csprojファイルを編集: csprojファイルを開く
            const string HALAPP_INCLUDE = "halapp";
            var config = ReadConfig();
            var csprojPath = Path.Combine(ProjectRoot, $"{config.ApplicationName}.csproj");
            var csproj = Microsoft.Build.Construction.ProjectRootElement.Open(csprojPath);

            // csprojファイルを編集: 既に設定があるなら削除
            var itemGroup = csproj.ItemGroups.SingleOrDefault(group => group.Items.Any(item => item.Include == HALAPP_INCLUDE));
            if (itemGroup != null) csproj.RemoveChild(itemGroup);

            // csprojファイルを編集: halapp.dll への参照を追加する（dll参照は dotnet add でサポートされていないため）
            itemGroup = csproj.AddItemGroup();
            var reference = itemGroup.AddItem("Reference", include: HALAPP_INCLUDE);
            reference.AddMetadata("HintPath", Path.Combine(HALAPP_DLL_COPY_TARGET, "halapp.dll"));

            // csprojファイルを編集: ビルド時に halapp.dll が含まれるディレクトリがコピーされるようにする
            var none = itemGroup.AddItem("None", Path.Combine(HALAPP_DLL_COPY_TARGET, "**", "*.*"));
            none.AddMetadata("CopyToOutputDirectory", "Always");

            csproj.Save();

            return this;
        }
        /// <summary>
        /// halapp.xml が無い場合作成します。
        /// </summary>
        internal HalappProject EnsureCreateHalappXml(string applicationName) {
            var xmlPath = GetAggregateSchemaPath();

            if (!File.Exists(xmlPath)) {
                var rootNamespace = applicationName.ToCSharpSafe();
                var config = new Config {
                    ApplicationName = applicationName,
                    DbContextName = "MyDbContext",
                    DbContextNamespace = $"{rootNamespace}.EntityFramework",
                    EntityFrameworkDirectoryRelativePath = "EntityFramework/__AutoGenerated",
                    EntityNamespace = $"{rootNamespace}.EntityFramework.Entities",
                    MvcControllerDirectoryRelativePath = "Controllers/__AutoGenerated",
                    MvcControllerNamespace = $"{rootNamespace}.Controllers",
                    MvcModelDirectoryRelativePath = "Models/__AutoGenerated",
                    MvcModelNamespace = $"{rootNamespace}.Models",
                    MvcViewDirectoryRelativePath = "Views/_AutoGenerated",
                    OutProjectDir = ".",
                };
                var xmlContent = new XDocument(config.ToXmlWithRoot());
                using var sw = new StreamWriter(xmlPath, append: false, encoding: new UTF8Encoding(false));
                sw.WriteLine(xmlContent.ToString());
            }

            return this;
        }
        /// <summary>
        /// データベースが存在しない場合に新規作成します。
        /// </summary>
        /// <returns></returns>
        public HalappProject EnsureCreateDatabase() {

            // sqliteファイル出力先フォルダが無い場合は作成する
            var dbDir = Path.Combine(ProjectRoot, "bin", "Debug");
            if (!Directory.Exists(dbDir)) Directory.CreateDirectory(dbDir);

            var migrator = new DotnetEf(new Terminal {
                WorkingDirectory = ProjectRoot,
                Verbose = _verbose,
            });
            if (!migrator.GetMigrations().Any()) {
                migrator.AddMigration();
            }
            migrator.Migrate();

            return this;
        }

        /// <summary>
        /// 必要なnpmモジュールをインストールします。
        /// </summary>
        public HalappProject InstallDependencies() {
            var npmProcess = new Terminal {
                WorkingDirectory = Path.Combine(ProjectRoot, REACT_DIR),
                Verbose = _verbose,
            };
            npmProcess.Exec("npm", "ci");

            // dotnetはビルド時に自動的にインストールされるので何もしない

            return this;
        }

        /// <summary>
        /// プロジェクトをビルドします。
        /// </summary>
        public void Build() {
            UpdateAutoGeneratedCode();

            var cmd = new Terminal {
                WorkingDirectory = ProjectRoot,
                Verbose = _verbose,
            };
            cmd.Exec("dotnet", "build");

            // TODO npm build
        }

        /// <summary>
        /// クライアントサイドプロセスのコマンドを作成します。
        /// </summary>
        internal BackgroundProcess CreateClientProcess(CancellationToken cancellationToken) {
            if (!IsValidDirectory()) throw new InvalidOperationException("Here is not halapp directory.");

            // TODO 未実装
            //using var npmStart = new DotnetEx.Cmd.Background {
            //    WorkingDirectory = Path.Combine(ProjectRoot, REACT_DIR),
            //    Filename = "npm",
            //    Args = new[] { "start" },
            //    CancellationToken = cancellationToken,
            //    Verbose = _verbose,
            //};

            //await npmStart.Restart();

            throw new NotImplementedException();
        }
        /// <summary>
        /// サーバーサイドプロセスのコマンドを作成します。
        /// ビルドは行いません。
        /// 実行中のソースファイルの変更は自動的に反映されません。
        /// </summary>
        internal BackgroundProcess CreateServerProcess(CancellationToken cancellationToken, TextWriter log) {
            if (!IsValidDirectory()) throw new InvalidOperationException("Here is not halapp directory.");

            var process = new BackgroundProcess {
                WorkingDirectory = ProjectRoot,
                Filename = "dotnet",
                Args = new[] { "run", "--no-build", "--launch-profile", "https" },
                CancellationToken = cancellationToken,
                IsReady = e => e.Data != null && AspCoreStartedRegex().IsMatch(e.Data),
            };
            process.OnStandardOut += (sender, e) => log.WriteLine(e.Data);
            process.OnStandardError += (sender, e) => log.WriteLine(e.Data);

            return process;
        }
        /// <summary>
        /// デバッグを開始します。
        /// </summary>
        public async Task StartDebugging(CancellationToken cancellationToken) {

            if (!IsValidDirectory()) return;

            var config = ReadConfig();
            var migrator = new DotnetEf(new Terminal {
                WorkingDirectory = ProjectRoot,
                Verbose = _verbose,
                CancellationToken = cancellationToken,
            });

            // 以下の2種類のキャンセルがあるので統合する
            // - ユーザーの操作による halapp debug 全体のキャンセル
            // - 集約定義ファイル更新によるビルドのキャンセル
            CancellationTokenSource? rebuildCancellation = null;
            CancellationTokenSource? linkedTokenSource = null;

            // バックグラウンド処理の宣言
            BackgroundProcess? dotnetRun = null;
            BackgroundProcess? npmStart = null;

            // ファイル変更監視用オブジェクト
            FileSystemWatcher? watcher = null;

            try {
                InstallDependencies();

                var changed = false;

                watcher = new FileSystemWatcher(ProjectRoot);
                watcher.Filter = HALAPP_XML_NAME;
                watcher.NotifyFilter = NotifyFilters.LastWrite;
                watcher.Changed += (_, _) => {
                    changed = true;
                    rebuildCancellation?.Cancel();
                };

                npmStart = new BackgroundProcess {
                    WorkingDirectory = Path.Combine(ProjectRoot, REACT_DIR),
                    Filename = "npm",
                    Args = new[] { "start" },
                    CancellationToken = cancellationToken,
                    IsReady = e => true, // TODO
                };

                // 監視開始
                watcher.EnableRaisingEvents = true;
                await npmStart.Launch();

                // リビルドの度に実行される処理
                while (true) {
                    dotnetRun?.Dispose();
                    rebuildCancellation?.Dispose();
                    linkedTokenSource?.Dispose();

                    rebuildCancellation = new CancellationTokenSource();
                    linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(
                        cancellationToken,
                        rebuildCancellation.Token);

                    try {
                        // ソースファイル再生成 & npm watch による自動更新
                        UpdateAutoGeneratedCode();

                        // DB定義の更新。
                        // halapp debug を実行するたびにマイグレーションファイルが積み重なっていくのを防ぐため、
                        // 最新のリリース済みマイグレーションまで巻き戻す
                        var latestRelease = string.Empty; // TODO: halapp release コマンドの結果と突き合わせる
                        var latestReleaseMigration = string.IsNullOrWhiteSpace(latestRelease)
                            ? migrator.GetMigrations().First().Name
                            : latestRelease;
                        migrator.RemoveMigrationsUntil(latestReleaseMigration);
                        migrator.AddMigration();
                        migrator.Migrate();

                        dotnetRun = CreateServerProcess(linkedTokenSource.Token, Console.Out);
                        await dotnetRun.Launch();

                    } catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested) {
                        throw; // デバッグ自体を中断

                    } catch (OperationCanceledException) when (rebuildCancellation.IsCancellationRequested) {
                        continue; // 実行中のビルドを中断してもう一度最初から

                    } catch (Exception ex) {
                        Console.ForegroundColor = ConsoleColor.Red;
                        Console.Error.WriteLine(ex.ToString());
                        Console.ResetColor();
                    }

                    changed = false;

                    // 次の更新まで待機
                    while (changed == false) {
                        Thread.Sleep(100);
                        cancellationToken.ThrowIfCancellationRequested();
                    }
                }

            } catch (OperationCanceledException) {
                Console.WriteLine("デバッグを中断します。");

            } finally {
                rebuildCancellation?.Dispose();
                linkedTokenSource?.Dispose();
                dotnetRun?.Dispose();
                npmStart?.Dispose();
                watcher?.Dispose();
            }
        }

        /// <summary>
        /// デバッグ時に起動されるアプリケーションのURLを返します。
        /// </summary>
        public Uri GetDebugUrl() {
            return new Uri(GetDebugApplicationUrl().Split(';')[1]);
        }
        /// <summary>
        /// デバッグ時に起動されるSwagger UIのURLを返します。
        /// </summary>
        /// <returns></returns>
        public Uri GetSwaggerUrl() {
            return new Uri(new Uri(GetDebugApplicationUrl().Split(';')[0]), "swagger");
        }
        /// <summary>
        /// launchSettings.jsonのhttpsプロファイルのapplicationUrlセクションの値を読み取ります。
        /// </summary>
        private string GetDebugApplicationUrl() {
            var properties = Path.Combine(ProjectRoot, "Properties");
            if (!Directory.Exists(properties)) throw new DirectoryNotFoundException(properties);
            var launchSettings = Path.Combine(properties, "launchSettings.json");
            if (!File.Exists(launchSettings)) throw new FileNotFoundException(launchSettings);

            var json = File.ReadAllText(launchSettings);
            var obj = JsonSerializer.Deserialize<JsonObject>(json);
            if (obj == null)
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (!obj.TryGetPropertyValue("profiles", out var profiles))
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (profiles == null)
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (!profiles.AsObject().TryGetPropertyValue("https", out var https))
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (https == null)
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (!https.AsObject().TryGetPropertyValue("applicationUrl", out var applicationUrl))
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (applicationUrl == null)
                throw new InvalidOperationException($"Invalid json: {launchSettings}");

            return applicationUrl.GetValue<string>();
        }

        /// <summary>
        /// デバッグのために、生成されるプロジェクトの詳細をオブジェクトとして返します。
        /// </summary>
        /// <exception cref="InvalidOperationException">アプリケーションスキーマが不正な場合</exception>
        internal AppSchema Inspect() {
            var xmlFullPath = GetAggregateSchemaPath();
            using var stream = IO.OpenFileWithRetry(xmlFullPath);
            using var reader = new StreamReader(stream);
            var xmlContent = reader.ReadToEnd();
            var xDocument = XDocument.Parse(xmlContent);
            var config = Config.GetDefault(xDocument.Root!.Name.LocalName);

            if (!AppSchemaBuilder.FromXml(xDocument, out var builder, out var errors)) {
                throw new InvalidOperationException(errors.Join(Environment.NewLine));
            }
            if (!builder.TryBuild(out var appSchema, out var errors1)) {
                throw new InvalidOperationException(errors1.Join(Environment.NewLine));
            }

            return appSchema;
        }

        /// <summary>
        /// dotnet ef のラッパー
        /// </summary>
        private partial class DotnetEf {

            internal DotnetEf(Terminal terminal) {
                _terminal = terminal;
            }
            private readonly Terminal _terminal;

            private bool _build = false;
            private void Build() {
                if (_build) return;
                _build = true;

                // このクラスの処理が走っているとき、基本的には dotnet run も並走しているので、Releaseビルドを指定しないとビルド先が競合して失敗してしまう
                _terminal.Exec("dotnet", "build", "--configuration", "Release");
            }

            internal IEnumerable<Migration> GetMigrations() {
                try {
                    Build();

                    var output = _terminal.ReadOutput(
                        "dotnet", "ef", "migrations", "list",
                        "--prefix-output", // ビルド状況やの行頭には "info:" が、マイグレーション名の行頭には "data:" がつくので、その識別のため
                        "--configuration", "Release",
                        "--no-build"); 

                    var regex = MigrationDataLineRegex();
                    return output
                        .Select(line => regex.Match(line))
                        .Where(match => match.Success)
                        .Select(match => new Migration {
                            Name = match.Groups[1].Value,
                            Pending = match.Groups.Count == 3,
                        })
                        .ToArray();
                } catch (Exception) {
                    return Enumerable.Empty<Migration>();
                }
            }
            internal void RemoveMigrationsUntil(string migrationName) {
                Build();

                // そのマイグレーションが適用済みだと migrations remove できないので、まず database update する
                _terminal.Exec("dotnet", "ef", "database", "update", migrationName, "--configuration", "Release", "--no-build");

                // リリース済みマイグレーションより後のマイグレーションを消す
                while (GetMigrations().Last().Name != migrationName) {
                    _terminal.Exec("dotnet", "ef", "migrations", "remove", "--configuration", "Release", "--no-build");
                }
            }
            internal void AddMigration() {
                Build();
                var migrationCount = GetMigrations().Count();
                var nextMigrationId = migrationCount.ToString("000000000000");
                _terminal.Exec("dotnet", "ef", "migrations", "add", nextMigrationId, "--configuration", "Release", "--no-build");

                // マイグレーションファイルが追加されたことにより再ビルドが必要
                _build = false;
            }
            internal void Migrate() {
                Build();
                _terminal.Exec("dotnet", "ef", "database", "update", "--configuration", "Release", "--no-build");
            }

            internal struct Migration {
                internal string Name { get; set; }
                internal bool Pending { get; set; }
            }

            [GeneratedRegex(@"^data:\s*([^\s]+)(\s\(Pending\))?$", RegexOptions.Multiline)]
            private static partial Regex MigrationDataLineRegex();
        }

        [GeneratedRegex("Now listening on:")]
        private static partial Regex AspCoreStartedRegex();
    }



    internal class HalappProject2 : HalappProject {

        internal HalappProject2(string projetctRoot, TextWriter? log, bool verbose) : base(projetctRoot, log, verbose) {

        }

        internal override HalappProject AddReferenceToHalappDll() {
            // 2ではhalapp.dllへの依存を排除しているので何もしない
            return this;
        }

        public override HalappProject UpdateAutoGeneratedCode() {
            if (!IsValidDirectory()) return this;

            _log?.WriteLine($"コード自動生成開始");

            var xmlFullPath = GetAggregateSchemaPath();
            using var stream = DotnetEx.IO.OpenFileWithRetry(xmlFullPath);
            using var reader = new StreamReader(stream);
            var xmlContent = reader.ReadToEnd();
            var xDocument = XDocument.Parse(xmlContent);
            var config = Core.Config.GetDefault(xDocument.Root!.Name.LocalName);

            if (!Core.AppSchemaBuilder.FromXml(xDocument, out var builder, out var errors)) {
                throw new InvalidOperationException(errors.Join(Environment.NewLine));
            }
            if (!builder.TryBuild(out var appSchema, out var errors1)) {
                throw new InvalidOperationException(errors1.Join(Environment.NewLine));
            }

            var ctx = new CodeRenderingContext {
                Config = config,
                Schema = appSchema,
            };

            DirectorySetupper.Directory(ProjectRoot, _log, dir => {

                dir.Directory("__AutoGenerated", genDir => {
                    genDir.Generate(new Configure(ctx));

                    foreach (var aggregate in ctx.Schema.RootAggregates()) {
                        genDir.Generate(new AggFile(aggregate, ctx));
                    }

                    genDir.Directory("Util", utilDir => {
                        utilDir.Generate(new CodeRendering.Util.RuntimeSettings(ctx));
                        utilDir.Generate(new CodeRendering.Util.DotnetExtensions(ctx.Config));
                        utilDir.Generate(new CodeRendering.Util.FromTo(ctx.Config));
                        utilDir.Generate(new CodeRendering.Util.InstanceKey(ctx));
                        utilDir.Generate(new CodeRendering.Util.AggregateInstanceKeyNamePair(ctx.Config));
                        utilDir.DeleteOtherFiles();
                    });
                    genDir.Directory("Web", controllerDir => {
                        controllerDir.Generate(new CodeRendering.Presentation.AggregateInstanceBase(ctx));
                        controllerDir.Generate(new CodeRendering.Presentation.SearchConditionBase(ctx));
                        controllerDir.Generate(new CodeRendering.Presentation.SearchResultBase(ctx));
                        controllerDir.Generate(new DebuggerController(ctx));
                        controllerDir.DeleteOtherFiles();
                    });
                    genDir.Directory("EntityFramework", efDir => {
                        efDir.Generate(new DbContext(ctx));
                        efDir.DeleteOtherFiles();
                    });
                    genDir.DeleteOtherFiles();
                });

                var reactProjectTemplate = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)!, "client");
                if (!Directory.Exists(Path.Combine(dir.Path, REACT_DIR))) {
                    DotnetEx.IO.CopyDirectory(reactProjectTemplate, Path.Combine(dir.Path, REACT_DIR));
                }

                dir.Directory(Path.Combine(REACT_DIR, "src", "__autoGenerated"), reactDir => {
                    const string REACT_PAGE_DIR = "pages";
                    string GetAggDirName(GraphNode<Aggregate> a) => a.Item.DisplayName.ToFileNameSafe();

                    reactDir.CopyFrom(Path.Combine(reactProjectTemplate, "src", "__autoGenerated", "halapp.css"));
                    reactDir.CopyFrom(Path.Combine(reactProjectTemplate, "src", "__autoGenerated", "halapp.types.ts"));
                    reactDir.Generate(new index(ctx, a => $"{REACT_PAGE_DIR}/{GetAggDirName(a)}"));
                    reactDir.Generate(new types(ctx));

                    reactDir.Directory("components", componentsDir => {
                        var source = Path.Combine(reactProjectTemplate, "src", "__autoGenerated", "components");
                        foreach (var file in Directory.GetFiles(source)) componentsDir.CopyFrom(file);
                        foreach (var template in ComboBox.All(ctx)) componentsDir.Generate(template);
                        componentsDir.DeleteOtherFiles();
                    });
                    reactDir.Directory("hooks", componentsDir => {
                        var source = Path.Combine(reactProjectTemplate, "src", "__autoGenerated", "hooks");
                        foreach (var file in Directory.GetFiles(source)) componentsDir.CopyFrom(file);
                        componentsDir.DeleteOtherFiles();
                    });
                    reactDir.Directory(REACT_PAGE_DIR, pageDir => {
                        foreach (var root in ctx.Schema.RootAggregates()) {
                            pageDir.Directory(GetAggDirName(root), aggregateDir => {
                                aggregateDir.Generate(new CreateView(root, ctx));
                                aggregateDir.Generate(new MultiView(root, ctx));
                                aggregateDir.Generate(new SingleView(root, ctx));
                                aggregateDir.DeleteOtherFiles();
                            });
                        }
                        pageDir.DeleteOtherFiles();
                    });
                    reactDir.DeleteOtherFiles();
                });
            });

            return this;
        }

        private class DirectorySetupper {
            internal static void Directory(string absolutePath, TextWriter? log, Action<DirectorySetupper> fn) {
                var setupper = new DirectorySetupper(absolutePath, log);
                setupper.Directory("", fn);
            }
            private DirectorySetupper(string path, TextWriter? log) {
                Path = path;
                _log = log;
                _generated = new HashSet<string>();
            }

            internal string Path { get; }
            private readonly TextWriter? _log;
            private readonly HashSet<string> _generated;
            internal void Directory(string relativePath, Action<DirectorySetupper> fn) {
                var fullpath = System.IO.Path.Combine(Path, relativePath);
                if (!System.IO.Directory.Exists(fullpath))
                    System.IO.Directory.CreateDirectory(fullpath);

                _generated.Add(fullpath);

                fn(new DirectorySetupper(System.IO.Path.Combine(Path, relativePath), _log));
            }

            internal void Generate(ITemplate template) {
                var file = System.IO.Path.Combine(Path, template.FileName);

                _generated.Add(file);

                _log?.WriteLine($"CREATING ... {file}");
                using var sw = new StreamWriter(file, append: false, encoding: GetEncoding(file));
                sw.WriteLine(template.TransformText());
            }
            internal void CopyFrom(string copySourceFile) {
                var copyTargetFile = System.IO.Path.Combine(Path, System.IO.Path.GetFileName(copySourceFile));

                _generated.Add(copyTargetFile);

                _log?.WriteLine($"CREATING ... {copyTargetFile}");
                var encoding = GetEncoding(copySourceFile);
                using var reader = new StreamReader(copySourceFile, encoding);
                using var writer = new StreamWriter(copyTargetFile, append: false, encoding: encoding);
                while (!reader.EndOfStream) {
                    writer.WriteLine(reader.ReadLine());
                }
            }
            internal void DeleteOtherFiles() {
                var deleteFiles = System.IO.Directory
                    .GetFiles(Path)
                    .Where(path => !_generated.Contains(path));
                foreach (var file in deleteFiles) {
                    if (!File.Exists(file)) continue;
                    _log?.WriteLine($"DELETE ... {file}");
                    File.Delete(file);
                }
                var deletedDirectories = System.IO.Directory
                    .GetDirectories(Path)
                    .Where(path => !_generated.Contains(path));
                foreach (var dir in deletedDirectories) {
                    if (!System.IO.Directory.Exists(dir)) continue;
                    _log?.WriteLine($"DELETE ... {dir}");
                    System.IO.Directory.Delete(dir);
                }
            }

            private static Encoding GetEncoding(string filepath) {
                return System.IO.Path.GetExtension(filepath).ToLower() == "cs"
                    ? Encoding.UTF8 // With BOM
                    : new UTF8Encoding(false);
            }
        }
    }
}
