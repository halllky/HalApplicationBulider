using HalApplicationBuilder.CodeRendering.ReactAndWebApi;
using HalApplicationBuilder.CodeRendering20230514;
using HalApplicationBuilder.CodeRendering20230514.EFCore;
using HalApplicationBuilder.CodeRendering20230514.ReactAndWebApi;
using HalApplicationBuilder.Core;
using HalApplicationBuilder.DotnetEx;
using Microsoft.Build.Evaluation;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Xml.Linq;
using static HalApplicationBuilder.HalappProject;
using static Microsoft.EntityFrameworkCore.DbLoggerCategory;

namespace HalApplicationBuilder {
    public class HalappProject {

        private protected const string HALAPP_XML_NAME = "halapp.xml";
        private protected const string REACT_DIR = "ClientApp";
        internal const string REACT_PAGE_DIR = "pages";
        private protected const string HALAPP_DLL_COPY_TARGET = "halapp-resource";

        /// <summary>
        /// 新しいhalappプロジェクトを作成します。
        /// </summary>
        /// <param name="applicationName">アプリケーション名</param>
        /// <param name="verbose">ログの詳細出力を行うかどうか</param>
        /// <returns>作成されたプロジェクトを表すオブジェクト</returns>
        public static HalappProject Create(string? applicationName, bool keepTempIferror, CancellationToken? cancellationToken = null, TextWriter? log = null, bool verbose = false) {

            if (string.IsNullOrWhiteSpace(applicationName))
                throw new InvalidOperationException($"Please specify name of new application. example 'halapp create my-new-app'");

            if (Path.GetInvalidFileNameChars().Any(applicationName.Contains))
                throw new InvalidOperationException($"'{applicationName}' contains invalid characters for a file name.");

            var projectRoot = Path.Combine(Directory.GetCurrentDirectory(), applicationName);
            if (Directory.Exists(projectRoot))
                throw new InvalidOperationException($"'{projectRoot}' is already exists.");

            var ramdomName = $"halapp.temp.{Path.GetRandomFileName()}";
            var tempDir = Path.Combine(Directory.GetCurrentDirectory(), ramdomName);

            var error = false;
            try {
                var tempProject = new HalappProject2(tempDir, cancellationToken, log, verbose);

                Directory.CreateDirectory(tempDir);

                tempProject.EnsureCreateHalappXml(applicationName);

                tempProject.DotnetNew();

                tempProject.EditProgramCs();
                tempProject.UpdateAutoGeneratedCode();

                tempProject.AddNugetPackages();
                tempProject.AddReferenceToHalappDll();

                tempProject.EnsureCreateRuntimeSettingFile();
                tempProject.EnsureCreateDatabase();

                tempProject.InstallNodeModules();

                // git initial commit
                var cmd = new Cmd {
                    WorkingDirectory = tempDir,
                    CancellationToken = cancellationToken,
                    Verbose = verbose,
                };
                cmd.Exec("git", "init");
                cmd.Exec("git", "add", ".");
                cmd.Exec("git", "commit", "-m", "init");

                // ここまでの処理がすべて成功したら一時ディレクトリを本来のディレクトリ名に変更
                if (Directory.Exists(projectRoot)) throw new InvalidOperationException($"プロジェクトディレクトリを {projectRoot} に移動できません。");
                Directory.Move(tempDir, projectRoot);

                log?.WriteLine("プロジェクト作成完了");

                return new HalappProject2(projectRoot, cancellationToken, log, verbose);

            } catch {
                error = true;
                throw;

            } finally {
                if (Directory.Exists(tempDir)
                    && (keepTempIferror == false || error == false)) {
                    Directory.Delete(tempDir, true);
                }
            }
        }
        /// <summary>
        /// 既存のhalappプロジェクトを開きます。
        /// </summary>
        /// <param name="path">プロジェクトルートディレクトリの絶対パス</param>
        /// <returns>作成されたプロジェクトを表すオブジェクト</returns>
        public static HalappProject Open(string? path, CancellationToken? cancellationToken = null, TextWriter? log = null, bool verbose = false) {
            if (string.IsNullOrWhiteSpace(path))
                return new HalappProject2(Directory.GetCurrentDirectory(), cancellationToken, log, verbose);
            else if (Path.IsPathRooted(path))
                return new HalappProject2(path, cancellationToken, log, verbose);
            else
                return new HalappProject2(Path.Combine(Directory.GetCurrentDirectory(), path), cancellationToken, log, verbose);
        }

        private protected HalappProject(string projetctRoot, CancellationToken? cancellationToken, TextWriter? log, bool verbose) {
            if (string.IsNullOrWhiteSpace(projetctRoot))
                throw new ArgumentException($"'{nameof(projetctRoot)}' is required.");

            ProjectRoot = projetctRoot;
            _cancellationToken = cancellationToken;
            _log = log;
            _verbose = verbose;
            _cmd = new Cmd {
                WorkingDirectory = projetctRoot,
                CancellationToken = cancellationToken,
                Verbose = _verbose,
            };
        }

        protected readonly bool _verbose;
        protected readonly CancellationToken? _cancellationToken;
        protected readonly TextWriter? _log;

        private protected readonly Cmd _cmd;

        private protected string ProjectRoot { get; }
        private protected AppSchema ReadSchema() {
            using var stream = DotnetEx.IO.OpenFileWithRetry(GetAggregateSchemaPath());
            using var reader = new StreamReader(stream);
            var xmlContent = reader.ReadToEnd();
            var xDocument = XDocument.Parse(xmlContent);
            var appSchema = AppSchema.FromXml(xDocument);
            return appSchema;
        }
        private protected Config ReadConfig() {
            var xmlFullPath = GetAggregateSchemaPath();
            using var stream = DotnetEx.IO.OpenFileWithRetry(xmlFullPath);
            using var reader = new StreamReader(stream);
            var xmlContent = reader.ReadToEnd();
            var xDocument = XDocument.Parse(xmlContent);
            var config = Core.Config.FromXml(xDocument);
            return config;
        }

        public string GetAggregateSchemaPath() {
            return Path.Combine(ProjectRoot, HALAPP_XML_NAME);
        }

        /// <summary>
        /// このディレクトリがhalappのものとして妥当なものかどうかを検査します。
        /// </summary>
        public bool IsValidDirectory() {
            var errors = new List<string>();

            if (Path.GetInvalidPathChars().Any(ProjectRoot.Contains))
                errors.Add($"Invalid path format: '{ProjectRoot}'");

            if (!Directory.Exists(ProjectRoot))
                errors.Add($"Directory '{ProjectRoot}' is not exist.");

            var halappXml = GetAggregateSchemaPath();
            if (!File.Exists(halappXml))
                errors.Add($"'{halappXml}' is not found.");

            if (_log != null) {
                foreach (var error in errors) _log.WriteLine(error);
            }
            return errors.Count == 0;
        }

        #region CODE GENERATING

        /// <summary>
        /// dotnet new コマンドを実行します。
        /// </summary>
        public HalappProject DotnetNew() {
            _log?.WriteLine($"プロジェクトを作成します。");

            var config = ReadConfig();
            _cmd.Exec("dotnet", "new", "webapi", "--output", ".", "--name", config.ApplicationName);

            // Create .gitignore file
            _cmd.Exec("dotnet", "new", "gitignore");
            var filename = Path.Combine(ProjectRoot, ".gitignore");
            var gitignore = File.ReadAllLines(filename).ToList();
            gitignore.Insert(0, "# HalApplicationBuilder");
            gitignore.Insert(1, $"/{HALAPP_DLL_COPY_TARGET}/*");
            File.WriteAllLines(filename, gitignore);

            return this;
        }
        /// <summary>
        /// Program.cs ファイルを編集し、必要なソースコードを追記します。
        /// </summary>
        /// <returns></returns>
        public HalappProject EditProgramCs() {
            _log?.WriteLine($"Program.cs ファイルを書き換えます。");
            var programCsPath = Path.Combine(ProjectRoot, "Program.cs");
            var lines = File.ReadAllLines(programCsPath).ToList();
            var regex1 = new Regex(@"^.*[a-zA-Z]+ builder = .+;$");
            var position1 = lines.FindIndex(regex1.IsMatch);
            if (position1 == -1) throw new InvalidOperationException("Program.cs の中にIServiceCollectionを持つオブジェクトを初期化する行が見つかりません。");
            lines.InsertRange(position1 + 1, new[] {
                    $"",
                    $"/* HalApplicationBuilder によって自動生成されたコード ここから */",
                    $"var runtimeRootDir = System.IO.Directory.GetCurrentDirectory();",
                    $"HalApplicationBuilder.Runtime.HalAppDefaultConfigurer.Configure(builder.Services, runtimeRootDir);",
                    $"// HTMLのエンコーディングをUTF-8にする(日本語のHTMLエンコード防止)",
                    $"builder.Services.Configure<Microsoft.Extensions.WebEncoders.WebEncoderOptions>(options => {{",
                    $"    options.TextEncoderSettings = new System.Text.Encodings.Web.TextEncoderSettings(System.Text.Unicode.UnicodeRanges.All);",
                    $"}});",
                    $"// npm start で実行されるポートがASP.NETのそれと別なので",
                    $"builder.Services.AddCors(options => {{",
                    $"    options.AddDefaultPolicy(builder => {{",
                    $"        builder.AllowAnyOrigin()",
                    $"            .AllowAnyMethod()",
                    $"            .AllowAnyHeader();",
                    $"    }});",
                    $"}});",
                    $"/* HalApplicationBuilder によって自動生成されたコード ここまで */",
                    $"",
                });

            var regex2 = new Regex(@"^.*[a-zA-Z]+ app = .+;$");
            var position2 = lines.FindIndex(regex2.IsMatch);
            if (position2 == -1) throw new InvalidOperationException("Program.cs の中にappオブジェクトを初期化する行が見つかりません。");
            lines.InsertRange(position2 + 1, new[] {
                    $"",
                    $"/* HalApplicationBuilder によって自動生成されたコード ここから */",
                    $"// 前述AddCorsの設定をするならこちらも必要",
                    $"app.UseCors();",
                    $"/* HalApplicationBuilder によって自動生成されたコード ここまで */",
                    $"",
                });
            File.WriteAllLines(programCsPath, lines);

            return this;
        }
        /// <summary>
        /// コードの自動生成を行います。
        /// </summary>
        /// <param name="log">ログ出力先</param>
        public virtual HalappProject UpdateAutoGeneratedCode() {

            if (!IsValidDirectory()) return this;

            _log?.WriteLine($"コード自動生成開始");

            var config = ReadConfig();
            var rootAggregates = ReadSchema().GetRootAggregates(config).ToArray();
            var allAggregates = rootAggregates
                .SelectMany(a => a.GetDescendantsAndSelf())
                .ToArray();

            _log?.WriteLine("コード自動生成: DI設定");
            using (var sw = new StreamWriter(Path.Combine(ProjectRoot, "HalappDefaultConfigure.cs"), append: false, encoding: Encoding.UTF8)) {
                sw.Write(new CodeRendering.DefaultRuntimeConfigTemplate(config).TransformText());
            }

            _log?.WriteLine("コード自動生成: スキーマ定義");
            using (var sw = new StreamWriter(Path.Combine(ProjectRoot, "halapp.json"), append: false, encoding: Encoding.UTF8)) {
                var schema = new Serialized.AppSchemaJson {
                    Config = config.ToJson(onlyRuntimeConfig: true),
                    Aggregates = rootAggregates.Select(a => a.ToJson()).ToArray(),
                };
                sw.Write(System.Text.Json.JsonSerializer.Serialize(schema, new System.Text.Json.JsonSerializerOptions {
                    Encoder = System.Text.Encodings.Web.JavaScriptEncoder.Create(System.Text.Unicode.UnicodeRanges.All), // 日本語用
                    WriteIndented = true,
                    DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull, // nullのフィールドをシリアライズしない
                }));
            }

            var modelDir = Path.Combine(ProjectRoot, config.MvcModelDirectoryRelativePath);
            if (Directory.Exists(modelDir)) Directory.Delete(modelDir, recursive: true);
            Directory.CreateDirectory(modelDir);

            _log?.WriteLine("コード自動生成: UI Model");
            using (var sw = new StreamWriter(Path.Combine(modelDir, "Models.cs"), append: false, encoding: Encoding.UTF8)) {
                sw.Write(new CodeRendering.UIModelsTemplate(config, allAggregates).TransformText());
            }

            var efSourceDir = Path.Combine(ProjectRoot, config.EntityFrameworkDirectoryRelativePath);
            if (Directory.Exists(efSourceDir)) Directory.Delete(efSourceDir, recursive: true);
            Directory.CreateDirectory(efSourceDir);

            _log?.WriteLine("コード自動生成: DbContext");
            using (var sw = new StreamWriter(Path.Combine(efSourceDir, "DbContext.cs"), append: false, encoding: Encoding.UTF8)) {
                sw.Write(new CodeRendering.EFCore.DbContextTemplate(config).TransformText());
            }

            _log?.WriteLine("コード自動生成: Entity定義");
            using (var sw = new StreamWriter(Path.Combine(efSourceDir, "Entities.cs"), append: false, encoding: Encoding.UTF8)) {
                sw.Write(new CodeRendering.EFCore.EntityClassTemplate(config, allAggregates).TransformText());
            }
            _log?.WriteLine("コード自動生成: DbSet");
            using (var sw = new StreamWriter(Path.Combine(efSourceDir, "DbSet.cs"), append: false, encoding: Encoding.UTF8)) {
                sw.Write(new CodeRendering.EFCore.DbSetTemplate(config, allAggregates).TransformText());
            }
            _log?.WriteLine("コード自動生成: OnModelCreating");
            using (var sw = new StreamWriter(Path.Combine(efSourceDir, "OnModelCreating.cs"), append: false, encoding: Encoding.UTF8)) {
                sw.Write(new CodeRendering.EFCore.OnModelCreatingTemplate(config, allAggregates).TransformText());
            }
            _log?.WriteLine("コード自動生成: Search");
            using (var sw = new StreamWriter(Path.Combine(efSourceDir, "Search.cs"), append: false, encoding: Encoding.UTF8)) {
                sw.Write(new CodeRendering.EFCore.SearchMethodTemplate(config, rootAggregates).TransformText());
            }

            // Web API
            _log?.WriteLine("コード自動生成: .NET Core Web API Controller");
            using (var sw = new StreamWriter(Path.Combine(ProjectRoot, "Web", "__AutoGenerated.cs"), append: false, encoding: Encoding.UTF8)) {
                var template = new WebApiControllerTemplate(config, rootAggregates);
                sw.Write(template.TransformText());
            }
            using (var sw = new StreamWriter(Path.Combine(ProjectRoot, "Web", "Debugger.cs"), append: false, encoding: Encoding.UTF8)) {
                var template = new WebApiDebuggerTemplate(config);
                sw.Write(template.TransformText());
            }

            // React.js
            var utf8withoutBOM = new UTF8Encoding(false);
            var tsProjectSource = Path.Combine(Path.GetDirectoryName(
                Assembly.GetExecutingAssembly().Location)!,
                "CodeRendering",
                "ReactAndWebApi",
                "project-template");
            var tsProjectDist = Path.Combine(
                ProjectRoot,
                REACT_DIR);
            var tsAutoGeneratedSource = Path.Combine(tsProjectSource, "src", "__AutoGenerated");
            var tsAutoGeneratedDist = Path.Combine(tsProjectDist, "src", "__AutoGenerated");

            if (!Directory.Exists(tsProjectDist)) {
                DotnetEx.IO.CopyDirectory(tsProjectSource, tsProjectDist);
            }

            // menuItems.tsx
            using (var sw = new StreamWriter(Path.Combine(tsAutoGeneratedDist, CodeRendering.ReactAndWebApi.menuItems.FILE_NAME), append: false, encoding: utf8withoutBOM)) {
                var template = new CodeRendering.ReactAndWebApi.menuItems(rootAggregates);
                sw.Write(template.TransformText());
            }
            // index.ts
            using (var sw = new StreamWriter(Path.Combine(tsAutoGeneratedDist, CodeRendering.ReactAndWebApi.index.FILE_NAME), append: false, encoding: utf8withoutBOM)) {
                var template = new CodeRendering.ReactAndWebApi.index(config, rootAggregates);
                sw.Write(template.TransformText());
            }

            // 集約定義に基づかないreactモジュール
            _log?.WriteLine("コード自動生成: halapp標準モジュール");

            // 集約定義に基づかないreactモジュール: components
            var componentsIn = Path.Combine(tsAutoGeneratedSource, "components");
            var componentsOut = Path.Combine(tsAutoGeneratedDist, "components");
            DotnetEx.IO.CopyDirectory(componentsIn, componentsOut, deleteOnlyDist: true);

            // 集約定義に基づかないreactモジュール: hooks
            var hooksIn = Path.Combine(tsAutoGeneratedSource, "hooks");
            var hooksOut = Path.Combine(tsAutoGeneratedDist, "hooks");
            DotnetEx.IO.CopyDirectory(hooksIn, hooksOut, deleteOnlyDist: true);

            // 集約定義に基づかないreactモジュール: halapp.css
            using (var sr = new StreamReader(Path.Combine(tsAutoGeneratedSource, "halapp.css")))
            using (var sw = new StreamWriter(Path.Combine(tsAutoGeneratedDist, "halapp.css"), append: false, encoding: utf8withoutBOM)) {
                sw.WriteLine(sr.ReadToEnd());
            }

            // 集約定義
            _log?.WriteLine("コード自動生成: 集約のTypeScript型定義");
            using (var sw = new StreamWriter(Path.Combine(tsAutoGeneratedDist, ReactTypeDefTemplate.FILE_NAME), append: false, encoding: utf8withoutBOM)) {
                var template = new ReactTypeDefTemplate();
                sw.Write(template.TransformText());
            }
            // コンポーネント
            _log?.WriteLine("コード自動生成: 集約のReactコンポーネント");
            var reactPageDir = Path.Combine(tsAutoGeneratedDist, REACT_PAGE_DIR);
            if (!Directory.Exists(reactPageDir)) Directory.CreateDirectory(reactPageDir);
            var updatetdReactFiles = new HashSet<string>();
            foreach (var rootAggregate in rootAggregates) {
                var template = new ReactComponentTemplate(rootAggregate);
                var filepath = Path.Combine(reactPageDir, template.FileName);
                using var sw = new StreamWriter(filepath, append: false, encoding: utf8withoutBOM);
                sw.Write(template.TransformText());

                updatetdReactFiles.Add(filepath);
            }
            var deleteFiles = Directory
                .GetFiles(reactPageDir)
                .Where(file => !updatetdReactFiles.Contains(file));
            foreach (var filepath in deleteFiles) {
                File.Delete(filepath);
            }
            // コンボボックス
            _log?.WriteLine("コード自動生成: コンボボックス");
            using (var sw = new StreamWriter(Path.Combine(componentsOut, ComboBoxTemplate.FILE_NAME), append: false, encoding: utf8withoutBOM)) {
                var template = new ComboBoxTemplate(rootAggregates);
                sw.Write(template.TransformText());
            }

            _log?.WriteLine("コード自動生成終了");

            return this;
        }
        /// <summary>
        /// 必要なNuGetパッケージを参照に加えます。
        /// </summary>
        public HalappProject AddNugetPackages() {
            _log?.WriteLine($"Microsoft.EntityFrameworkCore パッケージへの参照を追加します。");
            _cmd.Exec("dotnet", "add", "package", "Microsoft.EntityFrameworkCore");

            _log?.WriteLine($"Microsoft.EntityFrameworkCore.Proxies パッケージへの参照を追加します。");
            _cmd.Exec("dotnet", "add", "package", "Microsoft.EntityFrameworkCore.Proxies");

            _log?.WriteLine($"Microsoft.EntityFrameworkCore.Design パッケージへの参照を追加します。"); // migration add に必要
            _cmd.Exec("dotnet", "add", "package", "Microsoft.EntityFrameworkCore.Design");

            _log?.WriteLine($"Microsoft.EntityFrameworkCore.Sqlite パッケージへの参照を追加します。");
            _cmd.Exec("dotnet", "add", "package", "Microsoft.EntityFrameworkCore.Sqlite");

            return this;
        }
        /// <summary>
        /// halapp.dllとその依存先をプロジェクトディレクトリにコピーする。実行時にRuntimeContextを参照しているため
        /// </summary>
        public HalappProject AddReferenceToHalappDll() {
            _log?.WriteLine($"halapp.dll を参照に追加します。");

            // dllのコピー
            var halappDirCopySource = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)!;
            var halappDirCopyDist = Path.Combine(ProjectRoot, HALAPP_DLL_COPY_TARGET);
            DotnetEx.IO.CopyDirectory(halappDirCopySource, halappDirCopyDist, deleteOnlyDist: true);

            // csprojファイルを編集: csprojファイルを開く
            const string HALAPP_INCLUDE = "halapp";
            var config = ReadConfig();
            var csprojPath = Path.Combine(ProjectRoot, $"{config.ApplicationName}.csproj");
            var csproj = Microsoft.Build.Construction.ProjectRootElement.Open(csprojPath);

            // csprojファイルを編集: 既に設定があるなら削除
            var itemGroup = csproj.ItemGroups.SingleOrDefault(group => group.Items.Any(item => item.Include == HALAPP_INCLUDE));
            if (itemGroup != null) csproj.RemoveChild(itemGroup);

            // csprojファイルを編集: halapp.dll への参照を追加する（dll参照は dotnet add でサポートされていないため）
            itemGroup = csproj.AddItemGroup();
            var reference = itemGroup.AddItem("Reference", include: HALAPP_INCLUDE);
            reference.AddMetadata("HintPath", Path.Combine(HALAPP_DLL_COPY_TARGET, "halapp.dll"));

            // csprojファイルを編集: ビルド時に halapp.dll が含まれるディレクトリがコピーされるようにする
            var none = itemGroup.AddItem("None", Path.Combine(HALAPP_DLL_COPY_TARGET, "**", "*.*"));
            none.AddMetadata("CopyToOutputDirectory", "Always");

            csproj.Save();

            return this;
        }
        /// <summary>
        /// halapp.xml が無い場合作成します。
        /// </summary>
        public HalappProject EnsureCreateHalappXml(string applicationName) {
            var xmlPath = GetAggregateSchemaPath();

            if (!File.Exists(xmlPath)) {
                var rootNamespace = applicationName.ToCSharpSafe();
                var config = new Config {
                    ApplicationName = applicationName,
                    DbContextName = "MyDbContext",
                    DbContextNamespace = $"{rootNamespace}.EntityFramework",
                    EntityFrameworkDirectoryRelativePath = "EntityFramework/__AutoGenerated",
                    EntityNamespace = $"{rootNamespace}.EntityFramework.Entities",
                    MvcControllerDirectoryRelativePath = "Controllers/__AutoGenerated",
                    MvcControllerNamespace = $"{rootNamespace}.Controllers",
                    MvcModelDirectoryRelativePath = "Models/__AutoGenerated",
                    MvcModelNamespace = $"{rootNamespace}.Models",
                    MvcViewDirectoryRelativePath = "Views/_AutoGenerated",
                    OutProjectDir = ".",
                };
                var xmlContent = new XDocument(config.ToXmlWithRoot());
                using var sw = new StreamWriter(xmlPath, append: false, encoding: new UTF8Encoding(false));
                sw.WriteLine(xmlContent.ToString());
            }

            return this;
        }
        /// <summary>
        /// 実行時設定ファイルを規定値で作成します。
        /// </summary>
        public HalappProject EnsureCreateRuntimeSettingFile() {
            var runtimeSettingPath = Path.Combine(ProjectRoot, CodeRendering.DefaultRuntimeConfigTemplate.HALAPP_RUNTIME_SERVER_SETTING_JSON);
            if (!File.Exists(runtimeSettingPath)) {
                _log?.WriteLine($"{CodeRendering.DefaultRuntimeConfigTemplate.HALAPP_RUNTIME_SERVER_SETTING_JSON} ファイルを作成します。");
                using var sw = new StreamWriter(runtimeSettingPath, false, new UTF8Encoding(false));
                sw.WriteLine(Runtime.RuntimeSettings.Server.GetDefault().ToJson());
            }
            return this;
        }
        /// <summary>
        /// データベースが存在しない場合に新規作成します。
        /// </summary>
        /// <returns></returns>
        public HalappProject EnsureCreateDatabase() {
            EnsureCreateRuntimeSettingFile();

            // sqliteファイル出力先フォルダが無い場合は作成する
            var dbDir = Path.Combine(ProjectRoot, "bin", "Debug");
            if (!Directory.Exists(dbDir)) Directory.CreateDirectory(dbDir);

            var migrator = new DotnetEf(new Cmd {
                WorkingDirectory = ProjectRoot,
                Verbose = _verbose,
                CancellationToken = _cancellationToken,
            });
            if (!migrator.GetMigrations().Any()) {
                migrator.AddMigration();
            }

            return this;
        }
        /// <summary>
        /// 必要なnpmモジュールを node_moduels にインストールします。
        /// </summary>
        public HalappProject InstallNodeModules() {
            var npmProcess = new DotnetEx.Cmd {
                WorkingDirectory = Path.Combine(ProjectRoot, REACT_DIR),
                CancellationToken = _cmd.CancellationToken,
                Verbose = _verbose,
            };
            npmProcess.Exec("npm", "ci");

            return this;
        }
        #endregion CODE GENERATING

        #region DEBUG COMMAND
        /// <summary>
        /// プロジェクトをビルドします。
        /// </summary>
        public void Build() {
            UpdateAutoGeneratedCode();
            _cmd.Exec("dotnet", "build");
        }
        /// <summary>
        /// デバッグを開始します。
        /// </summary>
        public void StartDebugging() {

            if (!IsValidDirectory()) return;
            if (_cancellationToken == null) throw new InvalidOperationException($"CancellationToken is required when debug.");

            var config = ReadConfig();
            var migrator = new DotnetEf(new Cmd {
                WorkingDirectory = ProjectRoot,
                Verbose = _verbose,
                CancellationToken = _cancellationToken,
            });

            // 以下の2種類のキャンセルがあるので統合する
            // - ユーザーの操作による halapp debug 全体のキャンセル
            // - 集約定義ファイル更新によるビルドのキャンセル
            CancellationTokenSource? rebuildCancellation = null;
            CancellationTokenSource? linkedTokenSource = null;

            // バックグラウンド処理の宣言
            DotnetEx.Cmd.Background? dotnetRun = null;
            DotnetEx.Cmd.Background? npmStart = null;

            // ファイル変更監視用オブジェクト
            FileSystemWatcher? watcher = null;

            try {
                var changed = false;

                watcher = new FileSystemWatcher(ProjectRoot);
                watcher.Filter = HALAPP_XML_NAME;
                watcher.NotifyFilter = NotifyFilters.LastWrite;
                watcher.Changed += (_, _) => {
                    changed = true;
                    rebuildCancellation?.Cancel();
                };

                npmStart = new DotnetEx.Cmd.Background {
                    WorkingDirectory = Path.Combine(ProjectRoot, REACT_DIR),
                    Filename = "npm",
                    Args = new[] { "start" },
                    CancellationToken = _cancellationToken,
                    Verbose = _verbose,
                };

                // 監視開始
                watcher.EnableRaisingEvents = true;
                npmStart.Restart();

                // リビルドの度に実行される処理
                while (true) {
                    dotnetRun?.Dispose();
                    rebuildCancellation?.Dispose();
                    linkedTokenSource?.Dispose();

                    rebuildCancellation = new CancellationTokenSource();
                    linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(
                        _cancellationToken!.Value,
                        rebuildCancellation.Token);

                    try {
                        // ソースファイル再生成 & npm watch による自動更新
                        UpdateAutoGeneratedCode();

                        // DB定義の更新。
                        // halapp debug を実行するたびにマイグレーションファイルが積み重なっていくのを防ぐため、
                        // 最新のリリース済みマイグレーションまで巻き戻す
                        var latestRelease = string.Empty; // TODO: halapp release コマンドの結果と突き合わせる
                        var latestReleaseMigration = string.IsNullOrWhiteSpace(latestRelease)
                            ? migrator.GetMigrations().First().Name
                            : latestRelease;
                        migrator.RemoveMigrationsUntil(latestReleaseMigration);
                        migrator.AddMigration();

                        dotnetRun = new DotnetEx.Cmd.Background {
                            WorkingDirectory = ProjectRoot,
                            Filename = "dotnet",
                            Args = new[] { "run", "--launch-profile", "https" },
                            CancellationToken = linkedTokenSource.Token,
                            Verbose = _verbose,
                        };
                        dotnetRun.Restart();

                    } catch (OperationCanceledException) when (_cancellationToken!.Value.IsCancellationRequested) {
                        throw; // デバッグ自体を中断

                    } catch (OperationCanceledException) when (rebuildCancellation.IsCancellationRequested) {
                        continue; // 実行中のビルドを中断してもう一度最初から

                    } catch (Exception ex) {
                        Console.ForegroundColor = ConsoleColor.Red;
                        Console.Error.WriteLine(ex.ToString());
                        Console.ResetColor();
                    }

                    changed = false;

                    // 次の更新まで待機
                    while (changed == false) {
                        Thread.Sleep(100);
                        _cancellationToken!.Value.ThrowIfCancellationRequested();
                    }
                }

            } catch (OperationCanceledException) {
                Console.WriteLine("デバッグを中断します。");

            } finally {
                rebuildCancellation?.Dispose();
                linkedTokenSource?.Dispose();
                dotnetRun?.Dispose();
                npmStart?.Dispose();
                watcher?.Dispose();
            }
        }

        /// <summary>
        /// dotnet ef のラッパー
        /// </summary>
        private class DotnetEf {

            internal DotnetEf(Cmd cmd) {
                _cmd = cmd;
            }
            private readonly Cmd _cmd;

            internal IEnumerable<Migration> GetMigrations() {
                var output = _cmd
                    .ReadOutput(
                        "dotnet", "ef", "migrations", "list",
                        "--prefix-output", // ビルド状況やの行頭には "info:" が、マイグレーション名の行頭には "data:" がつくので、その識別のため
                        "--configuration", "Release"); // このクラスの処理が走っているとき、基本的には dotnet run も並走しているので、Releaseビルドを指定しないとビルド先が競合して失敗してしまう

                var regex = new Regex(@"^data:\s*([^\s]+)(\s\(Pending\))?$", RegexOptions.Multiline);
                return output
                    .Select(line => regex.Match(line))
                    .Where(match => match.Success)
                    .Select(match => new Migration {
                        Name = match.Groups[1].Value,
                        Pending = match.Groups.Count == 3,
                    });
            }
            internal void RemoveMigrationsUntil(string migrationName) {
                // そのマイグレーションが適用済みだと migrations remove できないので、まず database update する
                _cmd.Exec("dotnet", "ef", "database", "update", migrationName, "--configuration", "Release");

                // リリース済みマイグレーションより後のマイグレーションを消す
                while (GetMigrations().Last().Name != migrationName) {
                    _cmd.Exec("dotnet", "ef", "migrations", "remove", "--configuration", "Release");
                }
            }
            internal void AddMigration() {
                var migrationCount = GetMigrations().Count();
                var nextMigrationId = migrationCount.ToString("000000000000");

                _cmd.Exec("dotnet", "ef", "migrations", "add", nextMigrationId, "--configuration", "Release");
                _cmd.Exec("dotnet", "ef", "database", "update", "--configuration", "Release");
            }

            internal struct Migration {
                internal string Name { get; set; }
                internal bool Pending { get; set; }
            }
        }
        #endregion DEBUG COMMAND
    }

    internal class HalappProject2 : HalappProject {

        internal HalappProject2(string projetctRoot, CancellationToken? cancellationToken, TextWriter? log, bool verbose) : base(projetctRoot, cancellationToken, log, verbose) {

        }

        public override HalappProject UpdateAutoGeneratedCode() {
            if (!IsValidDirectory()) return this;

            _log?.WriteLine($"コード自動生成開始");

            var xmlFullPath = GetAggregateSchemaPath();
            using var stream = DotnetEx.IO.OpenFileWithRetry(xmlFullPath);
            using var reader = new StreamReader(stream);
            var xmlContent = reader.ReadToEnd();
            var xDocument = XDocument.Parse(xmlContent);
            var config = Core20230514.Config.FromXml(xDocument);

            if (!Core20230514.AppSchemaBuilder.FromXml(xDocument, out var builder, out var errors)) {
                throw new InvalidOperationException(errors.Join(Environment.NewLine));
            }
            if (!builder.TryBuild(out var appSchema, out var errors1)) {
                throw new InvalidOperationException(errors1.Join(Environment.NewLine));
            }

            var ctx = new CodeRenderingContext {
                Config = config,
                Schema = appSchema,
            };
            var reactProjectTemplate = Path.Combine(
                Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)!,
                "CodeRendering",
                "ReactAndWebApi",
                "project-template");

            DirectorySetupper.Directory(ProjectRoot, _log, dir => {

                dir.Directory("__AutoGenerated", genDir => {
                    genDir.Generate(new Configure(ctx));

                    genDir.Directory("Util", utilDir => {
                        utilDir.Generate(new CodeRendering20230514.Util.RuntimeSettings(ctx));
                        utilDir.Generate(new CodeRendering20230514.Util.DotnetExtensions(ctx.Config));
                        utilDir.Generate(new CodeRendering20230514.Util.FromTo(ctx.Config));
                        utilDir.Generate(new CodeRendering20230514.Util.InstanceKey(ctx));
                        utilDir.DeleteOtherFiles();
                    });
                    genDir.Directory("Web", controllerDir => {
                        controllerDir.Generate(new CodeRendering20230514.Presentation.ApiInterface(ctx));
                        controllerDir.Generate(new CodeRendering20230514.Presentation.AggregateInstanceBase(ctx));
                        controllerDir.Generate(new CodeRendering20230514.Presentation.SearchConditionBase(ctx));
                        controllerDir.Generate(new CodeRendering20230514.Presentation.SearchResultBase(ctx));
                        controllerDir.Generate(new DebuggerController(ctx));
                        foreach (var template in Controller.All(ctx)) controllerDir.Generate(template);
                        controllerDir.DeleteOtherFiles();
                    });
                    genDir.Directory("EntityFramework", efDir => {
                        efDir.Generate(new DbContext(ctx));
                        efDir.Generate(new Entities(ctx));
                        efDir.Generate(new Search(ctx));
                        efDir.Generate(new Find(ctx));
                        efDir.DeleteOtherFiles();
                    });
                    genDir.DeleteOtherFiles();
                });

                if (!Directory.Exists(Path.Combine(dir.Path, REACT_DIR))) {
                    DotnetEx.IO.CopyDirectory(reactProjectTemplate, Path.Combine(dir.Path, REACT_DIR));
                }

                dir.Directory(Path.Combine(REACT_DIR, "src", "__AutoGenerated"), reactDir => {

                    reactDir.Generate(Path.Combine(reactProjectTemplate, "src", "__AutoGenerated", "halapp.css"));
                    reactDir.Generate(Path.Combine(reactProjectTemplate, "src", "__AutoGenerated", "halapp.types.ts"));
                    reactDir.Generate(new CodeRendering20230514.ReactAndWebApi.index(ctx, "pages"));
                    reactDir.Generate(new CodeRendering20230514.ReactAndWebApi.menuItems(ctx, "pages"));

                    reactDir.Directory("components", componentsDir => {
                        var source = Path.Combine(reactProjectTemplate, "src", "__AutoGenerated", "components");
                        foreach (var file in Directory.GetFiles(source)) componentsDir.Generate(file);
                        foreach (var template in ComboBox.All(ctx)) componentsDir.Generate(template);
                        componentsDir.DeleteOtherFiles();
                    });
                    reactDir.Directory("hooks", componentsDir => {
                        var source = Path.Combine(reactProjectTemplate, "src", "__AutoGenerated", "hooks");
                        foreach (var file in Directory.GetFiles(source)) componentsDir.Generate(file);
                        componentsDir.DeleteOtherFiles();
                    });
                    reactDir.Directory("pages", pageDir => {
                        foreach (var template in ReactComponent.All(ctx)) pageDir.Generate(template);
                        pageDir.DeleteOtherFiles();
                    });
                    reactDir.DeleteOtherFiles();
                });
            });

            return this;
        }

        private class DirectorySetupper {
            internal static void Directory(string absolutePath, TextWriter? log, Action<DirectorySetupper> fn) {
                var setupper = new DirectorySetupper(absolutePath, log);
                setupper.Directory("", fn);
            }
            private DirectorySetupper(string path, TextWriter? log) {
                Path = path;
                _log = log;
                _generated = new HashSet<string>();
            }

            internal string Path { get; }
            private readonly TextWriter? _log;
            private readonly HashSet<string> _generated;
            internal void Directory(string relativePath, Action<DirectorySetupper> fn) {
                var fullpath = System.IO.Path.Combine(Path, relativePath);
                if (!System.IO.Directory.Exists(fullpath))
                    System.IO.Directory.CreateDirectory(fullpath);

                _generated.Add(fullpath);

                fn(new DirectorySetupper(System.IO.Path.Combine(Path, relativePath), _log));
            }

            internal void Generate(ITemplate template) {
                var file = System.IO.Path.Combine(Path, template.FileName);

                _generated.Add(file);

                _log?.WriteLine($"CREATING ... {file}");
                using var sw = new StreamWriter(file, append: false, encoding: GetEncoding(file));
                sw.WriteLine(template.TransformText());
            }
            internal void Generate(string copySourceFile) {
                var copyTargetFile = System.IO.Path.Combine(Path, System.IO.Path.GetFileName(copySourceFile));

                _generated.Add(copyTargetFile);

                _log?.WriteLine($"CREATING ... {copyTargetFile}");
                var encoding = GetEncoding(copySourceFile);
                using var reader = new StreamReader(copySourceFile, encoding);
                using var writer = new StreamWriter(copyTargetFile, append: false, encoding: encoding);
                while (!reader.EndOfStream) {
                    writer.WriteLine(reader.ReadLine());
                }
            }
            internal void DeleteOtherFiles() {
                var deleteFiles = System.IO.Directory
                    .GetFiles(Path)
                    .Where(path => !_generated.Contains(path));
                foreach (var file in deleteFiles) {
                    if (!File.Exists(file)) continue;
                    _log?.WriteLine($"DELETE ... {file}");
                    File.Delete(file);
                }
                var deletedDirectories = System.IO.Directory
                    .GetDirectories(Path)
                    .Where(path => !_generated.Contains(path));
                foreach (var dir in deletedDirectories) {
                    if (!System.IO.Directory.Exists(dir)) continue;
                    _log?.WriteLine($"DELETE ... {dir}");
                    System.IO.Directory.Delete(dir);
                }
            }

            private static Encoding GetEncoding(string filepath) {
                return System.IO.Path.GetExtension(filepath).ToLower() == "cs"
                    ? Encoding.UTF8 // With BOM
                    : new UTF8Encoding(false);
            }
        }
    }
}
