using HalApplicationBuilder.DotnetEx;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace HalApplicationBuilder {
    public sealed partial class HalappProjectDebugger {
        internal HalappProjectDebugger(HalappProject project, TextWriter? log) {
            _project = project;
            _log = log;
        }

        private readonly HalappProject _project;
        private readonly TextWriter? _log;

        /// <summary>
        /// デバッグを開始します。
        /// </summary>
        public async Task StartDebugging(CancellationToken cancellationToken) {

            if (!_project.IsValidDirectory()) return;

            var config = _project.ReadConfig();

            // 以下の2種類のキャンセルがあるので統合する
            // - ユーザーの操作による halapp debug 全体のキャンセル
            // - 集約定義ファイル更新によるビルドのキャンセル
            CancellationTokenSource? rebuildCancellation = null;
            CancellationTokenSource? linkedTokenSource = null;

            // バックグラウンド処理の宣言
            BackgroundProcess? dotnetRun = null;
            BackgroundProcess? npmStart = null;

            // ファイル変更監視用オブジェクト
            FileSystemWatcher? watcher = null;

            try {
                InstallDependencies();

                var changed = false;

                watcher = new FileSystemWatcher(_project.ProjectRoot);
                watcher.Filter = Path.GetFileName(_project.GetAggregateSchemaPath());
                watcher.NotifyFilter = NotifyFilters.LastWrite;
                watcher.Changed += (_, _) => {
                    changed = true;
                    rebuildCancellation?.Cancel();
                };

                npmStart = _project.Debugger.CreateClientRunningProcess(_log ?? Console.Out, cancellationToken);
                await npmStart.Launch();

                watcher.EnableRaisingEvents = true;

                // リビルドの度に実行される処理
                while (true) {
                    dotnetRun?.Dispose();
                    rebuildCancellation?.Dispose();
                    linkedTokenSource?.Dispose();

                    rebuildCancellation = new CancellationTokenSource();
                    linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(
                        cancellationToken,
                        rebuildCancellation.Token);

                    try {
                        // ソースファイル再生成 & npm watch による自動更新
                        _project.CodeGenerator.UpdateAutoGeneratedCode();

                        // DB定義の更新。
                        // halapp debug を実行するたびにマイグレーションファイルが積み重なっていくのを防ぐため、
                        // 最新のリリース済みマイグレーションまで巻き戻す
                        var latestRelease = string.Empty; // TODO: halapp release コマンドの結果と突き合わせる
                        var latestReleaseMigration = string.IsNullOrWhiteSpace(latestRelease)
                            ? _project.Migrator.GetMigrations().First().Name
                            : latestRelease;
                        _project.Migrator.RemoveMigrationsUntil(latestReleaseMigration);
                        _project.Migrator.AddMigration();
                        _project.Migrator.Migrate();

                        dotnetRun = CreateServerRunningProcess(_log ?? Console.Out, linkedTokenSource.Token);
                        await dotnetRun.Launch();

                    } catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested) {
                        throw; // デバッグ自体を中断

                    } catch (OperationCanceledException) when (rebuildCancellation.IsCancellationRequested) {
                        continue; // 実行中のビルドを中断してもう一度最初から

                    } catch (Exception ex) {
                        Console.ForegroundColor = ConsoleColor.Red;
                        Console.Error.WriteLine(ex.ToString());
                        Console.ResetColor();
                    }

                    changed = false;

                    // 次の更新まで待機
                    while (changed == false) {
                        Thread.Sleep(100);
                        cancellationToken.ThrowIfCancellationRequested();
                    }
                }

            } catch (OperationCanceledException) {
                Console.WriteLine("デバッグを中断します。");

            } finally {
                rebuildCancellation?.Dispose();
                linkedTokenSource?.Dispose();
                dotnetRun?.Dispose();
                npmStart?.Dispose();
                watcher?.Dispose();
            }
        }

        /// <summary>
        /// クライアントサイドプロセスのコマンドを作成します。
        /// </summary>
        internal BackgroundProcess CreateClientRunningProcess(TextWriter log, CancellationToken cancellationToken) {
            if (!_project.IsValidDirectory()) throw new InvalidOperationException("Here is not halapp directory.");

            var process = new DotnetEx.BackgroundProcess {
                WorkingDirectory = _project.WebClientProjectRoot,
                Filename = "npm",
                Args = new[] { "run", "dev" },
                CancellationToken = cancellationToken,
                IsReady = e => ViteReadyConsole().IsMatch(e.Message), // viteのコンソール表示
            };
            process.Log += (sender, e) => log.WriteLine(e.Message);

            return process;
        }
        /// <summary>
        /// サーバーサイドプロセスのコマンドを作成します。
        /// ビルドは行いません。
        /// 実行中のソースファイルの変更は自動的に反映されません。
        /// </summary>
        internal BackgroundProcess CreateServerRunningProcess(TextWriter log, CancellationToken cancellationToken) {
            if (!_project.IsValidDirectory()) throw new InvalidOperationException("Here is not halapp directory.");

            var process = new BackgroundProcess {
                WorkingDirectory = _project.ProjectRoot,
                Filename = "dotnet",
                Args = new[] { "run", "--no-build", "--launch-profile", "https" },
                CancellationToken = cancellationToken,
                IsReady = e => AspCoreStartedRegex().IsMatch(e.Message),
            };
            process.Log += (sender, e) => log.WriteLine(e.Message);

            return process;
        }

        /// <summary>
        /// デバッグ時に起動されるアプリケーションのURLを返します。
        /// </summary>
        public Uri GetDebugUrl() {
            return new Uri(GetDebuggingServerUrl().Split(';')[1]);
        }
        /// <summary>
        /// デバッグ時に起動されるSwagger UIのURLを返します。
        /// </summary>
        /// <returns></returns>
        public Uri GetSwaggerUrl() {
            return new Uri(new Uri(GetDebuggingServerUrl().Split(';')[0]), "swagger");
        }
        /// <summary>
        /// launchSettings.jsonのhttpsプロファイルのapplicationUrlセクションの値を読み取ります。
        /// </summary>
        private string GetDebuggingServerUrl() {
            var properties = Path.Combine(_project.ProjectRoot, "Properties");
            if (!Directory.Exists(properties)) throw new DirectoryNotFoundException(properties);
            var launchSettings = Path.Combine(properties, "launchSettings.json");
            if (!File.Exists(launchSettings)) throw new FileNotFoundException(launchSettings);

            var json = File.ReadAllText(launchSettings);
            var obj = JsonSerializer.Deserialize<JsonObject>(json);
            if (obj == null)
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (!obj.TryGetPropertyValue("profiles", out var profiles))
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (profiles == null)
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (!profiles.AsObject().TryGetPropertyValue("https", out var https))
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (https == null)
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (!https.AsObject().TryGetPropertyValue("applicationUrl", out var applicationUrl))
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (applicationUrl == null)
                throw new InvalidOperationException($"Invalid json: {launchSettings}");

            return applicationUrl.GetValue<string>();
        }
        /// <summary>
        /// vite.config.ts からポートを参照してURLを生成して返します。
        /// </summary>
        /// <returns></returns>
        public Uri GetDebuggingClientUrl() {
            var viteConfigTs = Path.Combine(_project.ProjectRoot, HalappProject.REACT_DIR, "vite.config.ts");
            if (!File.Exists(viteConfigTs))
                throw new FileNotFoundException(viteConfigTs);

            using var stream = new StreamReader(viteConfigTs, Encoding.UTF8);
            var regex = new Regex(@"port:\s*([^,]*)");
            while (!stream.EndOfStream) {
                var line = stream.ReadLine();
                if (line == null) continue;
                var match = regex.Match(line);
                if (!match.Success) continue;
                var port = match.Groups[1].Value;
                return new Uri($"http://localhost:{port}");
            }

            throw new InvalidOperationException("vite.config.ts からポート番号を読み取れません。'port: 9999'のようにポートを設定している行があるか確認してください。");
        }

        /// <summary>
        /// 必要なnpmモジュールをインストールします。
        /// </summary>
        public HalappProjectDebugger InstallDependencies() {
            using var npmProcess = _project.CreateClientDirProcess("npm", "ci");
            npmProcess.Start();

            // dotnetはビルド時に自動的にインストールされるので何もしない

            return this;
        }

        /// <summary>
        /// プロジェクトをビルドします。
        /// </summary>
        /// <param name="noEmit">trueにするとnpmについてTypeScriptのエラーチェックのみ実行しビルド結果は出力しない</param>
        public async Task BuildAsync(bool noEmit = false) {
            using var cmd1 = _project.CreateProcess("dotnet", "build");
            using var cmd2 = noEmit
                ? _project.CreateClientDirProcess("npm", "run", "tsc")
                : _project.CreateClientDirProcess("npm", "run", "build");
            await Task.WhenAll(cmd1.StartAsync(), cmd2.StartAsync());
        }

        [GeneratedRegex("Now listening on:")]
        private static partial Regex AspCoreStartedRegex();
        [GeneratedRegex("➜")]
        private static partial Regex ViteReadyConsole();
    }
}
