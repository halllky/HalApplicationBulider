<#@ template language="C#" linePragmas="false" #>
<#@ output encoding="utf-8" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="HalApplicationBuilder.CodeRendering.Util" #>
import React, { forwardRef, ForwardedRef, useState, useCallback } from "react"
import { useQuery } from "react-query"
import { useFormContext } from 'react-hook-form';
import { Combobox } from "@headlessui/react"
import { ChevronUpDownIcon } from "@heroicons/react/24/outline"
import { NowLoading } from "./NowLoading"
import { useAppContext } from "../hooks/AppContext"
import { usePageContext } from "../hooks/PageContext"
import { useHttpRequest } from "../hooks/useHttpRequest"

export const <#=ComponentName#> = forwardRef(({ raectHookFormId }: {
  raectHookFormId: string
}, ref: ForwardedRef<HTMLElement>) => {

  const [{ pageIsReadOnly },] = usePageContext()

  const [keyword, setKeyword] = useState('')
  const { get } = useHttpRequest()
  const [, dispatch] = useAppContext()
  const { data, refetch, isFetching } = useQuery({
    queryKey: ['<#=UseQueryKey#>'],
    queryFn: async () => {
      const response = await get<<#=AggregateInstanceKeyNamePair.TS_DEF#>[]>(`<#=Api#>`, { keyword })
      return response.ok ? response.data : []
    },
    onError: error => {
      dispatch({ type: 'pushMsg', msg: `ERROR!: ${JSON.stringify(error)}` })
    },
  })

  const [setTimeoutHandle, setSetTimeoutHandle] = useState<NodeJS.Timeout | undefined>(undefined)
  const onChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setKeyword(e.target.value)
    if (setTimeoutHandle !== undefined) clearTimeout(setTimeoutHandle)
    setSetTimeoutHandle(setTimeout(() => {
      refetch()
      setSetTimeoutHandle(undefined)
    }, 300))
  }, [setKeyword, setTimeoutHandle, setSetTimeoutHandle, refetch])
  const onBlur = useCallback(() => {
    if (setTimeoutHandle !== undefined) clearTimeout(setTimeoutHandle)
    setSetTimeoutHandle(undefined)
    refetch()
  }, [setTimeoutHandle, setSetTimeoutHandle, refetch])

  const { watch, setValue } = useFormContext()
  const onChangeSelectedValue = useCallback((value?: <#=AggregateInstanceKeyNamePair.TS_DEF#>) => {
    setValue(raectHookFormId, value)
  }, [setValue, watch])
  const displayValue = useCallback((item?: <#=AggregateInstanceKeyNamePair.TS_DEF#>) => {
    return item?.name || ''
  }, [])

  return (
    <Combobox ref={ref} value={watch(raectHookFormId) || null} onChange={onChangeSelectedValue} nullable disabled={pageIsReadOnly}>
      <div className="relative <#=FormOfAggregateInstance.INPUT_WIDTH#>">
        <Combobox.Input displayValue={displayValue} onChange={onChange} onBlur={onBlur} className="w-full" spellCheck="false" autoComplete="off" />
        {!pageIsReadOnly &&
          <Combobox.Button className="absolute inset-y-0 right-0 flex items-center pr-2">
            <ChevronUpDownIcon className="h-5 w-5 text-gray-400" aria-hidden="true" />
          </Combobox.Button>}
        <Combobox.Options className="absolute mt-1 w-full overflow-auto bg-white py-1 shadow-lg focus:outline-none">
          {(setTimeoutHandle !== undefined || isFetching) &&
            <NowLoading />}
          {(setTimeoutHandle === undefined && !isFetching && data?.length === 0) &&
            <span className="p-1 text-sm select-none opacity-50">データなし</span>}
          {(setTimeoutHandle === undefined && !isFetching) && data?.map(item => (
            <Combobox.Option key={item.<#=AggregateInstanceKeyNamePair.JSON_KEY#>} value={item}>
              {({ active }) => (
                <div className={active ? 'bg-neutral-200' : ''}>
                  {item.<#=AggregateInstanceKeyNamePair.JSON_NAME#>}
                </div>
              )}
            </Combobox.Option>
          ))}
        </Combobox.Options>
      </div>
    </Combobox>
  )
})
