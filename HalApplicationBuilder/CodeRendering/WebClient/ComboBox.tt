<#@ template language="C#" linePragmas="false" #>
<#@ output encoding="utf-8" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="HalApplicationBuilder.CodeRendering.Util" #>
import React, { forwardRef, ForwardedRef, useState, useCallback } from "react"
import { useQuery } from "react-query"
import { useFormContext } from 'react-hook-form';
import { Combobox } from "@headlessui/react"
import { useAppContext } from "../hooks/AppContext"
import { usePageContext } from "../hooks/PageContext"
import { useHttpRequest } from "../hooks/useHttpRequest"

export const <#=ComponentName#> = forwardRef(({ raectHookFormId }: {
  raectHookFormId: string
}, ref: ForwardedRef<HTMLElement>) => {

  const [{ readOnly },] = usePageContext()

  const [keyword, setKeyword] = useState('')
  const { get } = useHttpRequest()
  const [, dispatch] = useAppContext()
  const { data, refetch } = useQuery({
    queryKey: ['<#=UseQueryKey#>'],
    queryFn: async () => {
      const response = await get<<#=AggregateInstanceKeyNamePair.TS_DEF#>[]>(`<#=Api#>`, { keyword })
      return response.ok ? response.data : []
    },
    onError: error => {
      dispatch({ type: 'pushMsg', msg: `ERROR!: ${JSON.stringify(error)}` })
    },
  })

  const [setTimeoutHandle, setSetTimeoutHandle] = useState<NodeJS.Timeout | undefined>(undefined)
  const onChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setKeyword(e.target.value)
    if (setTimeoutHandle !== undefined) clearTimeout(setTimeoutHandle)
    setSetTimeoutHandle(setTimeout(() => refetch(), 1000))
  }, [setKeyword, setTimeoutHandle, setSetTimeoutHandle, refetch])
  const onBlur = useCallback(() => {
    if (setTimeoutHandle !== undefined) clearTimeout(setTimeoutHandle)
    setSetTimeoutHandle(undefined)
    refetch()
  }, [setTimeoutHandle, setSetTimeoutHandle, refetch])

  const { watch, setValue } = useFormContext()
  const selectedValue = watch(raectHookFormId)?.key || null
  const onChangeSelectedValue = useCallback((value?: { key: string, name: string }) => {
    setValue(raectHookFormId, value)
  }, [setValue, watch])

  return (
    <Combobox ref={ref} value={selectedValue} onChange={onChangeSelectedValue} nullable disabled={readOnly}>
      <Combobox.Input onChange={onChange} onBlur={onBlur} />
      <Combobox.Options>
        {data?.map(item => (
          <Combobox.Option key={item.<#=AggregateInstanceKeyNamePair.JSON_KEY#>} value={item}>
            {item.<#=AggregateInstanceKeyNamePair.JSON_NAME#>}
          </Combobox.Option>
        ))}
      </Combobox.Options>
    </Combobox>
  )
})
