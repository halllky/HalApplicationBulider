<#@ template language="C#" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
import React, { useState, useCallback } from 'react';
import { useCtrlS } from '../hooks/useCtrlS';
import { useAppContext } from '../hooks/AppContext';
import { AgGridReact } from 'ag-grid-react';
import { Link, useNavigate, useParams } from 'react-router-dom';
import { useQuery } from 'react-query';
import { FieldValues, SubmitHandler, useForm } from 'react-hook-form';
import { BookmarkIcon, ChevronDownIcon, ChevronUpIcon, MagnifyingGlassIcon, PlusIcon, BookmarkSquareIcon } from '@heroicons/react/24/outline';
import { IconButton } from '../components/IconButton';
import { <#=_searchCondition.ClassName#>, <#=_searchResult.ClassName#>/*, <#=_uiInstance.ClassName#> */ } from '<#=GetImportFromTypes()#>';

export const <#=MultiViewComponentName#> = () => {

    const [{ apiDomain }, dispatch] = useAppContext()
    useCtrlS(() => {
        dispatch({ type: 'pushMsg', msg: '保存しました。' })
    })

    const [param, setParam] = useState<<#=_searchCondition.ClassName#>>({} as <#=_searchCondition.ClassName#>) // TODO
    const { register, handleSubmit, reset } = useForm()
    const onSearch: SubmitHandler<FieldValues> = useCallback(data => {
        setParam(data as <#=_searchCondition.ClassName#>)
    }, [])
    const onClear = useCallback((e: React.MouseEvent) => {
        reset()
        e.preventDefault()
    }, [reset])
    const { data, isLoading, error } = useQuery({
        queryKey: ['<#=_rootAggregate.GetGuid()#>', JSON.stringify(param)],
        queryFn: async () => {
            const json = JSON.stringify(param)
            const encoded = window.encodeURI(json)
            const response = await fetch(`${apiDomain}/<#=_rootAggregate.GetCSharpSafeName()#>/list?param=${encoded}`)
            if (!response.ok) throw new Error('Network response was not OK.')
            return (await response.json()) as <#=_searchResult.ClassName#>[]
        },
    })

    const navigate = useNavigate()
    const toCreateView = useCallback(() => {
        navigate('<#=CreateViewUrl#>')
    }, [navigate])

    const [expanded, setExpanded] = useState(true)
    
    if (error) return <p>Error: {JSON.stringify(error)}</p>

    return (
        <div className="ag-theme-alpine compact flex flex-col space-y-1">

            <div className="flex flex-row justify-start items-center space-x-1">
                <div className='flex-1 flex flex-row items-center space-x-1 cursor-pointer' onClick={() => setExpanded(!expanded)}>
                    <h1 className="text-base font-semibold select-none py-1">
                        <#=_rootAggregate.GetDisplayName()#>
                    </h1>
                    {expanded
                        ? <ChevronDownIcon className="w-4" />
                        : <ChevronUpIcon className="w-4" />}
                </div>
                <IconButton icon={PlusIcon} onClick={toCreateView}>新規作成</IconButton>
            </div>

            <form className={`${expanded ? '' : 'hidden'} flex flex-col space-y-1`} onSubmit={handleSubmit(onSearch)}>
<# PushIndent("                "); #>
<# _rootAggregate.RenderReactSearchCondition(new RenderingContext(this, new ObjectPath("searchCondition"))); #>
<# PopIndent(); #>
                <div className='flex flex-row justify-start space-x-1'>
                    <IconButton icon={MagnifyingGlassIcon}>検索</IconButton>
                    <IconButton outline onClick={onClear}>クリア</IconButton>
                    <div className="flex-1"></div>
                    <IconButton outline icon={BookmarkIcon}>この検索条件を保存</IconButton>
                </div>
            </form>

            <AgGridReact
                className="flex-1"
                rowData={isLoading ? [] : data}
                columnDefs={columnDefs}
                multiSortKey='ctrl'
                undoRedoCellEditing
                undoRedoCellEditingLimit={20}>
            </AgGridReact>
        </div>
    )
}

const columnDefs = [
    {
        resizable: true,
        cellRenderer: ({ data }: { data: { <#=nameof(Runtime.SearchResultBase.__halapp__InstanceKey)#>: string } }) => {
            const encoded = window.encodeURI(data.<#=nameof(Runtime.SearchResultBase.__halapp__InstanceKey)#>)
            return <Link to={`<#=SingleViewUrl#>/${encoded}`} className="text-blue-400">詳細</Link>
        },
    },
<# foreach (var prop in _searchResult.Properties) { #>
    { field: '<#=prop.PropertyName#>', resizable: true, sortable: true, editable: true },
<# } #>
]

export const <#=CreateViewComponentName#> = () => {

    const { register, handleSubmit } = useForm()
    const navigate = useNavigate()
    const [{ apiDomain },] = useAppContext()
    const onSave: SubmitHandler<FieldValues> = useCallback(async data => {
        const response = await fetch(`${apiDomain}/<#=_rootAggregate.GetCSharpSafeName()#>/create`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data),
        })
        if (response.ok) {
            const { instanceKey } = JSON.parse(await response.text())
            const encoded = window.encodeURI(instanceKey)
            navigate(`<#=SingleViewUrl#>/${encoded}`)
        }
    }, [apiDomain, navigate])

    return (
        <form className="flex flex-col justify-start space-y-1" onSubmit={handleSubmit(onSave)}>
            <h1 className="text-base font-semibold select-none py-1">
                <Link to="<#=MultiViewUrl#>"><#=_rootAggregate.GetDisplayName()#></Link>
                &nbsp;&#047;&nbsp;
                新規作成
            </h1>
            <div className="flex flex-col space-y-1">
<# PushIndent("                "); #>
<# _rootAggregate.RenderReactSearchCondition(new RenderingContext(this, new ObjectPath("instance"))); #>
<# PopIndent(); #>
            </div>
            <IconButton icon={BookmarkSquareIcon} className="self-start">保存</IconButton>
        </form>
    )
}

export const <#=SingleViewComponentName#> = () => {

    const [{ apiDomain }, dispatch] = useAppContext()
    const { instanceKey } = useParams()
    const { register, handleSubmit } = useForm({
        defaultValues: async () => {
            if (!instanceKey) return undefined
            const encoded = window.encodeURI(instanceKey)
            const response = await fetch(`${apiDomain}/<#=_rootAggregate.GetCSharpSafeName()#>/detail/${encoded}`)
            if (response.ok) {
                const data = await response.text()
                return JSON.parse(data)
            } else {
                return undefined
            }
        },
    })
    const onSave: SubmitHandler<FieldValues> = useCallback(async data => {
        const response = await fetch(`${apiDomain}/<#=_rootAggregate.GetCSharpSafeName()#>/update`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data),
        })
        if (response.ok) {
            dispatch({ type: 'pushMsg', msg: '更新しました。' })
        }
    }, [apiDomain])

    return (
        <form className="flex flex-col justify-start space-y-1" onSubmit={handleSubmit(onSave)}>
            <h1 className="text-base font-semibold select-none py-1">
                <Link to="<#=MultiViewUrl#>"><#=_rootAggregate.GetDisplayName()#></Link>
                &nbsp;&#047;&nbsp;
                <span className="select-all">TODO:INSTANCENAME</span>
            </h1>
<# PushIndent("            "); #>
<# _rootAggregate.RenderReactSearchCondition(new RenderingContext(this, new ObjectPath("instance"))); #>
<# PopIndent(); #>
            <IconButton icon={BookmarkSquareIcon} className="self-start">更新</IconButton>
        </form>
    )
}
