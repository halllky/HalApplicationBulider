<#@ template language="C#" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
import React, { useState, useCallback } from 'react';
import { useCtrlS } from '../hooks/useCtrlS';
import { useAppContext } from '../hooks/AppContext';
import { AgGridReact } from 'ag-grid-react';
import { Link, useNavigate, useParams } from 'react-router-dom';
import { useQuery } from 'react-query';
import { FieldValues, SubmitHandler, useForm } from 'react-hook-form';
import { UUID } from 'uuidjs'
import { BookmarkIcon, ChevronDownIcon, ChevronUpIcon, MagnifyingGlassIcon, PlusIcon, BookmarkSquareIcon } from '@heroicons/react/24/outline';
import { IconButton } from '../components/IconButton';
import { InlineMessageBar, BarMessage } from '../components/InlineMessageBar';

export const <#=MultiViewComponentName#> = () => {

    const [{ apiDomain }, dispatch] = useAppContext()
    useCtrlS(() => {
        dispatch({ type: 'pushMsg', msg: '保存しました。' })
    })

    const [param, setParam] = useState<FieldValues>({})
    const { register, handleSubmit, reset } = useForm()
    const onSearch: SubmitHandler<FieldValues> = useCallback(data => {
        setParam(data)
    }, [])
    const onClear = useCallback((e: React.MouseEvent) => {
        reset()
        e.preventDefault()
    }, [reset])
    const { data, isFetching } = useQuery({
        queryKey: ['<#=_rootAggregate.GetGuid()#>', JSON.stringify(param)],
        queryFn: async () => {
            const json = JSON.stringify(param)
            const encoded = window.encodeURI(json)
            const response = await fetch(`${apiDomain}/<#=_rootAggregate.GetCSharpSafeName()#>/list?param=${encoded}`)
            if (!response.ok) throw new Error('Network response was not OK.')
            return await response.json()
        },
        onError: error => {
            dispatch({ type: 'pushMsg', msg: `ERROR!: ${JSON.stringify(error)}` })
        },
    })

    const navigate = useNavigate()
    const toCreateView = useCallback(() => {
        navigate('<#=CreateViewUrl#>')
    }, [navigate])

    const [expanded, setExpanded] = useState(true)

    if (isFetching) return <></>

    return (
        <div className="page-content-root ag-theme-alpine compact">

            <div className="flex flex-row justify-start items-center space-x-1">
                <div className='flex flex-row items-center space-x-1 cursor-pointer' onClick={() => setExpanded(!expanded)}>
                    <h1 className="text-base font-semibold select-none py-1">
                        <#=_rootAggregate.GetDisplayName()#>
                    </h1>
                    {expanded
                        ? <ChevronDownIcon className="w-4" />
                        : <ChevronUpIcon className="w-4" />}
                </div>
                <IconButton underline icon={PlusIcon} onClick={toCreateView}>新規作成</IconButton>
            </div>

            <form className={`${expanded ? '' : 'hidden'} flex flex-col space-y-1`} onSubmit={handleSubmit(onSearch)}>
<# PushIndent("                "); #>
<# _rootAggregate.RenderReactSearchCondition(new RenderingContext(this, new ObjectPath("searchCondition"))); #>
<# PopIndent(); #>
                <div className='flex flex-row justify-start space-x-1'>
                    <IconButton fill icon={MagnifyingGlassIcon}>検索</IconButton>
                    <IconButton outline onClick={onClear}>クリア</IconButton>
                    <div className="flex-1"></div>
                    <IconButton underline icon={BookmarkIcon}>この検索条件を保存</IconButton>
                </div>
            </form>

            <AgGridReact
                className="flex-1"
                rowData={data || []}
                columnDefs={columnDefs}
                multiSortKey='ctrl'
                undoRedoCellEditing
                undoRedoCellEditingLimit={20}>
            </AgGridReact>
        </div>
    )
}

const columnDefs = [
    {
        resizable: true,
        width: 50,
        cellRenderer: ({ data }: { data: { <#=nameof(Runtime.SearchResultBase.__halapp__InstanceKey)#>: string } }) => {
            const encoded = window.encodeURI(data.<#=nameof(Runtime.SearchResultBase.__halapp__InstanceKey)#>)
            return <Link to={`<#=SingleViewUrl#>/${encoded}`} className="text-blue-400">詳細</Link>
        },
    },
<# foreach (var prop in _searchResult.Properties) { #>
    { field: '<#=prop.PropertyName#>', resizable: true, sortable: true, editable: true },
<# } #>
]

export const <#=CreateViewComponentName#> = () => {

    const { register, handleSubmit } = useForm()
    const navigate = useNavigate()
    const [{ apiDomain },] = useAppContext()
    const [errorMessages, setErrorMessages] = useState<BarMessage[]>([])
    const onSave: SubmitHandler<FieldValues> = useCallback(async data => {
        const response = await fetch(`${apiDomain}/<#=_rootAggregate.GetCSharpSafeName()#>/create`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data),
        })
        if (response.ok) {
            setErrorMessages([])
            const { instanceKey } = JSON.parse(await response.text())
            const encoded = window.encodeURI(instanceKey)
            navigate(`<#=SingleViewUrl#>/${encoded}`)
        } else {
            const errors: string[] = JSON.parse(await response.text())
            setErrorMessages([...errorMessages, ...errors.map(text => ({ uuid: UUID.generate(), text }))])
        }
    }, [apiDomain, navigate, errorMessages])

    return (
        <form className="page-content-root" onSubmit={handleSubmit(onSave)}>
            <h1 className="text-base font-semibold select-none py-1">
                <Link to="<#=MultiViewUrl#>"><#=_rootAggregate.GetDisplayName()#></Link>&nbsp;新規作成
            </h1>
            <InlineMessageBar value={errorMessages} onChange={setErrorMessages} />
            <div className="flex flex-col space-y-1">
<# PushIndent("                "); #>
<# _rootAggregate.RenderReactSearchCondition(new RenderingContext(this, new ObjectPath("instance"))); #>
<# PopIndent(); #>
            </div>
            <IconButton fill icon={BookmarkSquareIcon} className="self-start">保存</IconButton>
        </form>
    )
}

export const <#=SingleViewComponentName#> = () => {

    const [{ apiDomain }, dispatch] = useAppContext()

    const { instanceKey } = useParams()
    const [fetched, setFetched] = useState(false)
    const defaultValues = useCallback(async () => {
        if (!instanceKey) return undefined
        const encoded = window.encodeURI(instanceKey)
        const response = await fetch(`${apiDomain}/<#=_rootAggregate.GetCSharpSafeName()#>/detail/${encoded}`)
        setFetched(true)
        if (response.ok) {
            const data = await response.text()
            return JSON.parse(data)
        } else {
            return undefined
        }
    }, [instanceKey, apiDomain])

    const { register, handleSubmit } = useForm({ defaultValues })
    const [errorMessages, setErrorMessages] = useState<BarMessage[]>([])
    const onSave: SubmitHandler<FieldValues> = useCallback(async data => {
        const response = await fetch(`${apiDomain}/<#=_rootAggregate.GetCSharpSafeName()#>/update`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data),
        })
        if (response.ok) {
            setErrorMessages([])
            dispatch({ type: 'pushMsg', msg: '更新しました。' })
        } else {
            const errors: string[] = JSON.parse(await response.text())
            setErrorMessages([...errorMessages, ...errors.map(text => ({ uuid: UUID.generate(), text }))])
        }
    }, [apiDomain, errorMessages, dispatch])

    if (!fetched) return <></>

    return (
        <form className="page-content-root" onSubmit={handleSubmit(onSave)}>
            <h1 className="text-base font-semibold select-none py-1">
                <Link to="<#=MultiViewUrl#>"><#=_rootAggregate.GetDisplayName()#></Link>
                &nbsp;&#047;&nbsp;
                <span className="select-all">TODO:INSTANCENAME</span>
            </h1>
            <InlineMessageBar value={errorMessages} onChange={setErrorMessages} />
<# PushIndent("            "); #>
<# _rootAggregate.RenderReactSearchCondition(new RenderingContext(this, new ObjectPath("instance"))); #>
<# PopIndent(); #>
            <IconButton fill icon={BookmarkSquareIcon} className="self-start">更新</IconButton>
        </form>
    )
}
