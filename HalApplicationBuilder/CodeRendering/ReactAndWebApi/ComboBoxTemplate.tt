<#@ template language="C#" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
import { forwardRef, ForwardedRef, useState } from "react"
import { useQuery } from "react-query"
import { Combobox } from "@headlessui/react"
import { useAppContext } from "../hooks/AppContext"
import { ReferenceDTO } from "../halapp.types"

<# foreach (var aggregate in _rootAggregates) { #>
/** <#=aggregate.GetDisplayName()#>のコンボボックス */
const <#=GetComboBoxName(aggregate)#> = forwardRef(({ value, onChange }: {
  value?: ReferenceDTO
  onChange?: (v: ReferenceDTO | undefined) => void
}, ref: ForwardedRef<HTMLElement>) => {

  const [{ apiDomain }, dispatch] = useAppContext()
  const [keyword, setKeyword] = useState('')
  const { data } = useQuery({
    queryKey: ['<#=GetQueryKey(aggregate)#>'],
    queryFn: async () => {
      const encoded = window.encodeURI(keyword)
      const response = await fetch(`${apiDomain}/<#=GetUrlSubDomain(aggregate)#>/list-by-keyword?keyword=${encoded}`)
      if (!response.ok) throw new Error('Network response was not OK.')
      return (await response.json()) as ReferenceDTO[]
    },
    onError: error => {
      dispatch({ type: 'pushMsg', msg: `ERROR!: ${JSON.stringify(error)}` })
    },
  })

  return (
    <Combobox ref={ref} value={value} onChange={onChange}>
      <Combobox.Input onChange={(event) => setKeyword(event.target.value)} />
      <Combobox.Options>
        {data?.map(referenceDto => (
          <Combobox.Option key={referenceDto.instanceKey} value={referenceDto.instanceKey}>
            {referenceDto.instanceName}
          </Combobox.Option>
        ))}
      </Combobox.Options>
    </Combobox>
  )
})
<# } #>

export const ComboBoxes = {
<# foreach (var aggregate in _rootAggregates) { #>
  <#=GetComboBoxName(aggregate)#>,
<# } #>
}
