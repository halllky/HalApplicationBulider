import React from 'react'
import * as Layout from './__autoGenerated/collection'
import * as Input from './__autoGenerated/input'
import * as Util from './__autoGenerated/util'
import { AggregateOrMemberTypeKey, GridRow, OptionalAttributeKey, PageState } from './types'
import { TypeComboReturns } from './useTypeCombo'

/** グリッド列定義 */
export const useColumnDef = (
  optionalAttributes: PageState['optionalAttributes'],
  { typeComboSource, typeComboProps }: TypeComboReturns
) => {

  return React.useMemo((): Layout.DataTableColumn<GridRow>[] => {

    // -------------------------------------
    // 集約名（階層構造）
    const displayNameColumn: Layout.DataTableColumn<GridRow> = {
      id: 'col-A',
      ...textCell(
        row => row.item.displayName ?? '',
        (row, value) => { row.item.displayName = value },
      ),
      defaultWidthPx: 320,
      render: row => (
        <div className="flex overflow-x-hidden">
          <div style={{ flexBasis: row.depth * 24 }}></div>
          <CellText className="flex-1">
            {row.item.displayName}
          </CellText>
        </div>
      ),
    }

    // -------------------------------------
    // 集約またはメンバーの型
    const setValueTypeCell = (row: GridRow, value: unknown) => {
      if (typeComboSource?.some(t => t.key === value)) {
        row.item.type = value as AggregateOrMemberTypeKey
      } else {
        row.item.type = undefined
      }
    }
    const typeColumns: Layout.DataTableColumn<GridRow> = {
      id: 'col-B',
      header: '種類',
      onClipboardCopy: row => row.item.type ?? '',
      render: row => (
        <CellText>{typeComboSource?.find(t => t.key === row.item.type)?.displayName ?? row.item.type}</CellText>
      ),
      editSetting: {
        type: 'combo',
        comboProps: typeComboProps,
        onStartEditing: row => row.item.type,
        onEndEditing: setValueTypeCell,
        onClipboardPaste: setValueTypeCell,
      },
    }

    // -------------------------------------
    // 集約またはメンバーの型の詳細情報（step や variation-item の数値指定）

    // -------------------------------------
    // オプション列
    const optionColumns: Layout.DataTableColumn<GridRow>[] = []
    for (let i = 0; i < (optionalAttributes?.length ?? 0); i++) {
      const def = optionalAttributes![i]
      if (def.type === 'boolean') {
        // 真偽値型のオプション
        const setBooleanValue = (row: GridRow, key: OptionalAttributeKey, value: boolean) => {
          const objValue = { key: key, value: '' }
          if (!row.item.attrValues) {
            row.item.attrValues = value ? [objValue] : []
          } else {
            const ix = row.item.attrValues?.findIndex(v => v.key === key)
            const arr = [...row.item.attrValues]
            if (value) {
              if (ix === -1) {
                arr.push(objValue)
              } else {
                arr.splice(ix, 1, objValue)
              }
            } else if (!value && ix !== -1) {
              arr.splice(ix, 1)
            }
            row.item.attrValues = arr
          }
        }
        const editSetting: Layout.ColumnEditSetting<GridRow, { key: 'T' | 'F', text: string }> = {
          type: 'combo',
          onStartEditing: row => row.item.attrValues?.some(v => v.key === def.key)
            ? { key: 'T', text: '✓' }
            : { key: 'F', text: '' },
          onEndEditing: (row, value) => {
            setBooleanValue(row, def.key, value?.key === 'T')
          },
          onClipboardPaste: (row, value) => {
            const normalized = Util.normalize(value).toLowerCase()
            const blnValue =
              normalized === 't'
              || normalized === 'true'
              || normalized === '1'
              || normalized === '✓'
            setBooleanValue(row, def.key, blnValue)
          },
          comboProps: {
            onFilter: async () => [{ key: 'T', text: '✓' }, { key: 'F', text: '' }],
            getOptionText: opt => opt.text,
            getValueFromOption: opt => opt,
            getValueText: value => value.text,
          }
        }
        optionColumns.push({
          id: `col-${i + 2}`,
          header: def.displayName,
          defaultWidthPx: 60,
          onClipboardCopy: row => row.item.attrValues?.some(v => v.key === def.key) ? 'true' : '',
          render: row => (
            <CellText className="px-1">
              {row.item.attrValues?.some(v => v.key === def.key) ? '✓' : ''}
            </CellText>
          ),
          editSetting: editSetting as Layout.ColumnEditSetting<GridRow, unknown>,
        })
        continue
      }

      const setStringValue = (row: GridRow, key: OptionalAttributeKey, value: string) => {
        if (!row.item.attrValues) {
          row.item.attrValues = value ? [{ key, value }] : []
        } else {
          const ix = row.item.attrValues?.findIndex(v => v.key === key)
          const arr = [...row.item.attrValues]
          if (value) {
            if (ix === -1) {
              arr.push({ key, value })
            } else {
              arr.splice(ix, 1, { key, value })
            }
          } else if (!value && ix !== -1) {
            arr.splice(ix, 1)
          }
          row.item.attrValues = arr
        }
      }

      if (def.type === 'number') {
        optionColumns.push({
          id: `col-${i + 2}`,
          header: def.displayName,
          defaultWidthPx: 60,
          onClipboardCopy: row => row.item.attrValues?.find(v => v.key === def.key)?.value ?? '',
          render: row => (
            <CellText className="px-1">
              {row.item.attrValues?.find(v => v.key === def.key)?.value}
            </CellText>
          ),
          editSetting: {
            type: 'text',
            onStartEditing: row => row.item.attrValues?.find(v => v.key === def.key)?.value,
            onEndEditing: (row, value) => {
              const num = value ? Number(Util.normalize(value)) : NaN
              setStringValue(row, def.key, isNaN(num) ? '' : num.toString())
            },
            onClipboardPaste: (row, text) => {
              const num = text ? Number(Util.normalize(text)) : NaN
              setStringValue(row, def.key, isNaN(num) ? '' : num.toString())
            },
          },
        })

      } else {
        optionColumns.push({
          id: `col-${i + 2}`,
          header: def.displayName,
          defaultWidthPx: 60,
          onClipboardCopy: row => row.item.attrValues?.find(v => v.key === def.key)?.value ?? '',
          render: row => (
            <CellText className="px-1">
              {row.item.attrValues?.find(v => v.key === def.key)?.value}
            </CellText>
          ),
          editSetting: {
            type: 'text',
            onStartEditing: row => row.item.attrValues?.find(v => v.key === def.key)?.value,
            onEndEditing: (row, value) => {
              setStringValue(row, def.key, value ?? '')
            },
            onClipboardPaste: (row, text) => {
              setStringValue(row, def.key, text)
            },
          },
        })
      }
    }

    return [
      displayNameColumn,
      typeColumns,
      ...optionColumns,
    ]
  }, [typeComboSource, typeComboProps, optionalAttributes])
}

const CellText = ({ className, children }: {
  className?: string
  children?: React.ReactNode
}) => {
  const title = typeof children === 'string' ? children : undefined

  return (
    <span title={title} className={`block text-ellipsis whitespace-nowrap overflow-x-hidden ${className}`}>
      {children}
      &nbsp;
    </span>
  )
}

const textCell = (
  getValue: (row: GridRow) => string,
  setValue: (row: GridRow, value: string | undefined) => void
): Pick<Layout.DataTableColumn<GridRow>, 'editSetting' | 'onClipboardCopy'> => ({
  onClipboardCopy: getValue,
  editSetting: {
    type: 'text',
    onClipboardPaste: setValue,
    onEndEditing: setValue,
    onStartEditing: getValue,
  },
})
