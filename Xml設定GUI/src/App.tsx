import React, { memo } from 'react'
import useEvent from 'react-use-event-hook'
import { useFieldArray, useWatch } from 'react-hook-form'
import * as Icon from '@heroicons/react/24/solid'
import * as Util from './__autoGenerated/util'
import * as Input from './__autoGenerated/input'
import * as Layout from './__autoGenerated/collection'
import { AggregateOrMember, GridRow, createNewGridRow, PageState } from './types'
import { useBackend } from './useBackend'
import { useColumnDef } from './useColumnDef'
import { useTypeCombo } from './useTypeCombo'
import { useFlattenArrayTree } from './useFlattenArrayTree'
import { useAppSetting } from './useAppSetting'

function App() {

  // データ
  const { ready, load, validate, save, backendDomain, onChangBackendDomain } = useBackend()
  const { registerEx, getValues, reset, control } = Util.useFormEx<PageState>({})
  const { fields, update, insert, remove } = useFieldArray({ name: 'aggregates', control })
  const fieldsRef = React.useRef<AggregateOrMember[]>()
  fieldsRef.current = fields
  const tree = useFlattenArrayTree(fieldsRef)

  // データ型の種類
  const aggregateOrMemberTypes = useWatch({ name: 'aggregateOrMemberTypes', control })
  const typeCombo = useTypeCombo(aggregateOrMemberTypes, fields, tree)

  // アプリ設定
  const editingXmlFilePath = useWatch({ name: 'editingXmlFilePath', control })
  const { openAppSettingDialog } = useAppSetting(backendDomain, onChangBackendDomain, editingXmlFilePath)

  // 列定義
  const optionalAttributes = useWatch({ name: 'optionalAttributes', control })
  const columns = useColumnDef(optionalAttributes, typeCombo)

  const gridRef = React.useRef<Layout.DataTableRef<GridRow>>(null)

  // 選択中の行の情報
  const [activeRowIndex, setActiveRowIndex] = React.useState<number>()
  const [activeRowTreeInfo, setActiveRowTreeInfo] = React.useState<{ member: string, type: string }[]>([])
  const handleActiveRowChanged = useEvent((activeRow?: { getRow: () => GridRow, rowIndex: number }) => {
    if (activeRow) {
      const row = activeRow.getRow()
      const ancestorsAndRow = [...tree.getAncestors(row), row]
      setActiveRowTreeInfo(ancestorsAndRow.map(row => {
        const type = typeCombo.typeComboSource.find(t => t.key === row.type)?.displayName ?? row.type
        return { member: row.displayName ?? '', type: type ? `（${type}）` : '' }
      }))
      setActiveRowIndex(activeRow.rowIndex)
    } else {
      setActiveRowTreeInfo([])
      setActiveRowIndex(undefined)
    }
  })

  // ----------------------
  // イベント

  // 挿入
  const insertRows = useEvent(() => {
    const selectedRows = gridRef.current?.getSelectedRows()
    if (selectedRows === undefined) return
    const index = Math.min(...selectedRows.map(r => r.rowIndex))
    const depth = fields[index]?.depth ?? 0
    const count = gridRef.current?.getSelectedRows().length ?? 0
    insert(index, Array.from({ length: count }).map(() => createNewGridRow(depth)))
  })

  // 下挿入
  const insertRowsBelow = useEvent(() => {
    const selectedRows = gridRef.current?.getSelectedRows()
    if (selectedRows === undefined) return
    const index = Math.max(...selectedRows.map(r => r.rowIndex)) + 1
    const depth = fields[index]?.depth ?? 0
    const count = selectedRows.length
    insert(index, Array.from({ length: count }).map(() => createNewGridRow(depth)))
  })

  // 削除
  const removeRows = useEvent(() => {
    const selectedRows = gridRef.current?.getSelectedRows().map(r => r.rowIndex)
    if (selectedRows !== undefined) remove(selectedRows)
  })

  // CHECK
  const executeValidate = useEvent(async () => {
    await validate(fields)
  })

  // 再読み込み
  const reload = useEvent(async () => {
    reset(await load())
  })

  // 保存
  const handleSave = useEvent(async () => {
    if (await save(fields)) {
      await reload()
    }
  })

  // 画面初期表示時
  React.useEffect(() => {
    if (ready) reload()
  }, [ready])

  return (
    <div className="flex flex-col w-full h-full p-1 gap-1">
      <div className="flex gap-1 items-center">
        <Input.IconButton onClick={insertRows} outline mini>挿入</Input.IconButton>
        <Input.IconButton onClick={insertRowsBelow} outline mini>下挿入</Input.IconButton>
        <Input.IconButton onClick={removeRows} outline mini>行削除</Input.IconButton>
        <div className="flex-1"></div>
        <Input.IconButton onClick={reload} icon={Icon.ArrowPathIcon} outline mini>再読み込み</Input.IconButton>
        <Input.IconButton onClick={executeValidate} icon={Icon.CheckIcon} outline mini>CHECK</Input.IconButton>
        <Input.IconButton onClick={openAppSettingDialog} icon={Icon.Cog6ToothIcon} outline mini>設定</Input.IconButton>
        <Input.IconButton onClick={handleSave} icon={Icon.BookmarkSquareIcon} fill mini>保存</Input.IconButton>
      </div>

      <Util.InlineMessageList />

      {/* 選択中の行の情報 */}
      <div className="flex flex-wrap gap-1 items-center select-none text-sm">
        {activeRowTreeInfo.map((info, ix) => (
          <React.Fragment key={ix}>
            {ix > 0 && <span className="text-color-5">&gt;</span>}
            <div className="bg-color-3 px-1 rounded-md">
              <span className="text-color-7">{info.member}</span>
              <span className="text-color-5">{info.type}</span>
            </div>
          </React.Fragment>
        ))}
        &nbsp;
      </div>

      {/* グリッド */}
      <Layout.DataTable
        ref={gridRef}
        data={fields}
        columns={columns}
        onChangeRow={update}
        onActiveRowChanged={handleActiveRowChanged}
        className="flex-1"
      />
    </div>
  )
}

const style: React.CSSProperties = {
  fontFamily: '"Cascadia Mono", "BIZ UDGothic"',
}

const AppAndContextProviders = () => {
  return (
    <div className="w-full h-full" style={style}>
      <Util.ToastContextProvider>
        <Util.MsgContextProvider>
          <Layout.DialogContextProvider>
            <App />
            <Util.Toast />
          </Layout.DialogContextProvider>
        </Util.MsgContextProvider>
      </Util.ToastContextProvider>
    </div>
  )
}

export default AppAndContextProviders
