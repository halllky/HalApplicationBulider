import React from 'react'
import useEvent from 'react-use-event-hook'
import { useFieldArray, useWatch } from 'react-hook-form'
import * as Util from './__autoGenerated/util'
import * as Input from './__autoGenerated/input'
import * as Layout from './__autoGenerated/collection'
import { GridRow, PageState } from './types'
import { useBackend } from './useBackend'
import { useColumnDef } from './useColumnDef'
import { useTypeCombo } from './useTypeCombo'

function App() {

  // データ
  const { ready, load, backendDomain, onChangBackendDomain } = useBackend()
  const { registerEx, reset, control } = Util.useFormEx<PageState>({})
  const { fields, update } = useFieldArray({ name: 'aggregates', control })

  // データ構造の変換を行う。
  // 集約データは、サーバー上では入れ子のツリー構造。
  // クライアント側ではグリッドで取り回ししやすいように深さのプロパティをもったフラットな配列。
  const flattenGridRows = React.useMemo((): GridRow[] => {
    const rootNodes = Util.toTree(fields as PageState['aggregates'] ?? [], {
      getId: agg => agg.uniqueId,
      getChildren: agg => agg.children,
    })
    return Util.flatten(rootNodes)
  }, [fields])

  // データ型の種類
  const aggregateOrMemberTypes = useWatch({ name: 'aggregateOrMemberTypes', control })
  const typeCombo = useTypeCombo(aggregateOrMemberTypes, flattenGridRows)

  // 列定義
  const optionalAttributes = useWatch({ name: 'optionalAttributes', control })
  const columns = useColumnDef(optionalAttributes, typeCombo)

  const gridRef = React.useRef<Layout.DataTableRef<GridRow>>(null)

  // 選択中の行の情報
  const [activeRowInfo, setActiveRowInfo] = React.useState<string[]>([])
  const handleActiveRowChanged = useEvent((activeRow?: { getRow: () => GridRow, rowIndex: number }) => {
    if (activeRow) {
      const row = activeRow.getRow()
      const ancestorsAndRow = [...Util.getAncestors(row), row]
      setActiveRowInfo(ancestorsAndRow.map(row => {
        const type = typeCombo.typeComboSource.find(t => t.key === row.item.type)?.displayName ?? row.item.type
        return (row.item.displayName ?? '') + (type ? `（${type}）` : '')
      }))
    } else {
      setActiveRowInfo([])
    }
  })

  // ----------------------
  // イベント

  const reload = useEvent(async () => {
    const initialState = await load()
    reset(initialState)
  })

  const handleUpdate = useEvent((rowIndex: number, row: GridRow) => {
    let rootNode: GridRow
    if (row.parent) {
      // 更新されたのが子孫要素の場合
      const indexInSiblings = row.parent.children.indexOf(row)
      row.parent.children.splice(indexInSiblings, 1, row)
      rootNode = Util.getAncestors(row)[0]
    } else {
      // 更新されたのがルート要素の場合
      rootNode = row
    }
    const rootNodeIndex = (fields as PageState['aggregates'] ?? []).indexOf(rootNode.item)
    update(rootNodeIndex, { ...rootNode.item })
  })

  React.useEffect(() => {
    if (ready) reload()
  }, [ready])

  return (
    <div className="flex flex-col w-full h-full p-1 gap-1" style={style}>
      <div className="flex gap-1 items-center">
        <label className="flex-1 flex gap-1 items-center">
          バックエンドURL
          <Input.Word value={backendDomain} onChange={onChangBackendDomain} className="flex-1" />
        </label>
        <Input.IconButton onClick={reload}>再読み込み</Input.IconButton>
      </div>
      <div className="flex gap-1 items-center">
        <label className="flex-1 flex gap-1 items-center">
          ファイル名
          <Input.Word {...registerEx('editingXmlFilePath')} className="flex-1" />
        </label>
      </div>

      {/* 選択中の行の情報 */}
      <div className="flex flex-wrap gap-1 items-center select-none text-sm">
        {activeRowInfo.map((rowDisplayName, ix) => (
          <React.Fragment key={ix}>
            {ix > 0 && <span className="text-color-5">&gt;</span>}
            <span className="bg-color-3 text-color-7 px-1 rounded-md">{rowDisplayName}</span>
          </React.Fragment>
        ))}
        &nbsp;
      </div>

      {/* グリッド */}
      <Layout.DataTable
        ref={gridRef}
        data={flattenGridRows}
        columns={columns}
        onChangeRow={handleUpdate}
        onActiveRowChanged={handleActiveRowChanged}
        className="flex-1"
      />
    </div>
  )
}

const style: React.CSSProperties = {
  fontFamily: '"Cascadia Mono", "BIZ UDGothic"',
}

const AppAndContextProviders = () => {
  return (
    <Layout.DialogContextProvider>
      <App />
    </Layout.DialogContextProvider>
  )
}

export default AppAndContextProviders
