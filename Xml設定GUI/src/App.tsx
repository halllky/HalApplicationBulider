import React from 'react'
import useEvent from 'react-use-event-hook'
import { useFieldArray, UseFormGetValues, useWatch } from 'react-hook-form'
import * as Icon from '@heroicons/react/24/solid'
import { Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels'
import mermaidEngine from 'mermaid'
import * as Util from './__autoGenerated/util'
import * as Input from './__autoGenerated/input'
import * as Layout from './__autoGenerated/collection'
import { AggregateOrMember, GridRow, createNewGridRow, PageState, ValidationError } from './types'
import { useBackend } from './useBackend'
import { useColumnDef } from './useColumnDef'
import { useTypeCombo } from './useTypeCombo'
import { useFlattenArrayTree } from './useFlattenArrayTree'
import { useAppSetting } from './useAppSetting'
import { useValidationErrorContext, ValidationErrorContextProvider } from './useValidationError'

function App() {

  // データ
  const { ready, load, validate, save, backendDomain, onChangBackendDomain } = useBackend()
  const rhfMethods = Util.useFormEx<PageState>({})
  const { getValues, reset, control } = rhfMethods
  const { fields, update, insert, remove, move } = useFieldArray({ name: 'aggregates', control })

  // ツリー構造関連の操作
  const fieldsRef = React.useRef<AggregateOrMember[]>()
  fieldsRef.current = fields
  const {
    collapsedRowIds,
    expandableRows,
    expandedRows,
    collapseAll,
    expandAll,
    toggleCollapsing,
    ...treeMethods
  } = useFlattenArrayTree(fields, fieldsRef)

  // ----------------------
  // データ型の種類
  const aggregateOrMemberTypes = useWatch({ name: 'aggregateOrMemberTypes', control })
  const typeCombo = useTypeCombo(aggregateOrMemberTypes, fields, treeMethods.getDescendants)

  // ----------------------
  // アプリ設定
  const editingXmlFilePath = useWatch({ name: 'editingXmlFilePath', control })
  const { openAppSettingDialog } = useAppSetting(rhfMethods, backendDomain, onChangBackendDomain, editingXmlFilePath)

  // ----------------------
  // 列定義
  const optionalAttributes = useWatch({ name: 'optionalAttributes', control })
  const columns = useColumnDef(optionalAttributes, typeCombo, expandableRows, collapsedRowIds, toggleCollapsing)

  const gridRef = React.useRef<Layout.DataTableRef<GridRow>>(null)

  // ----------------------
  // 選択中の行の情報
  const [activeRowUniqueId, setActiveRowUniqueId] = React.useState<GridRow['uniqueId']>()
  const [activeRowTreeInfo, setActiveRowTreeInfo] = React.useState<{ member: string, type: string }[]>([])
  const handleActiveRowChanged = useEvent((activeRow?: { getRow: () => GridRow, rowIndex: number }) => {
    if (activeRow) {
      const row = activeRow.getRow()
      const ancestorsAndRow = [...treeMethods.getAncestors(row), row]
      setActiveRowTreeInfo(ancestorsAndRow.map(row => {
        const type = typeCombo.typeComboSource.find(t => t.key === row.type)?.displayName ?? row.type
        return { member: row.displayName ?? '', type: type ? `（${type}）` : '' }
      }))
      setActiveRowUniqueId(row.uniqueId)
    } else {
      setActiveRowTreeInfo([])
      setActiveRowUniqueId(undefined)
    }
  })

  // ----------------------
  // イベント

  // 挿入
  const insertRows = useEvent(() => {
    expandAll()
    const selectedRows = gridRef.current?.getSelectedRows()
    if (selectedRows === undefined) return
    const index = Math.min(...selectedRows.map(r => r.rowIndex))
    const depth = fields[index]?.depth ?? 0
    const count = gridRef.current?.getSelectedRows().length ?? 0
    insert(index, Array.from({ length: count }).map(() => createNewGridRow(depth)))
    executeValidate()
  })

  // 下挿入
  const insertRowsBelow = useEvent(() => {
    expandAll()
    const selectedRows = gridRef.current?.getSelectedRows()
    if (selectedRows === undefined) return
    const index = Math.max(...selectedRows.map(r => r.rowIndex)) + 1
    const depth = fields[index]?.depth ?? 0
    const count = selectedRows.length
    insert(index, Array.from({ length: count }).map(() => createNewGridRow(depth)))
    executeValidate()
  })

  // 削除
  const removeRows = useEvent(() => {
    expandAll()
    const selectedRows = gridRef.current?.getSelectedRows().map(r => r.rowIndex)
    if (selectedRows !== undefined) remove(selectedRows)
    executeValidate()
  })

  // インデント上げ下げ
  const handleIncreaseIndent = useEvent(() => {
    expandAll()
    const selectedRows = gridRef.current?.getSelectedRows()
    if (!selectedRows) return
    for (const { rowIndex, row } of selectedRows) {
      update(rowIndex, { ...row, depth: Math.max(0, row.depth - 1) })
    }
    executeValidate()
  })
  const handleDecreaseIndent = useEvent(() => {
    expandAll()
    const selectedRows = gridRef.current?.getSelectedRows()
    if (!selectedRows) return
    for (const { rowIndex, row } of selectedRows) {
      update(rowIndex, { ...row, depth: row.depth + 1 })
    }
    executeValidate()
  })

  // 列の上下移動
  const handleMoveAbove = useEvent(() => {
    const selectedRowIndexes = gridRef.current?.getSelectedRows().map(x => x.rowIndex)
    if (selectedRowIndexes === undefined) return
    const min = Math.min(...selectedRowIndexes)
    const max = Math.max(...selectedRowIndexes)
    if (min === 0) return
    expandAll()
    move(min - 1, max)
    gridRef.current?.selectRow(min - 1, max - 1)
  })
  const handleMoveBelow = useEvent(() => {
    const selectedRowIndexes = gridRef.current?.getSelectedRows().map(x => x.rowIndex)
    if (selectedRowIndexes === undefined) return
    const min = Math.min(...selectedRowIndexes)
    const max = Math.max(...selectedRowIndexes)
    if (max >= (fields.length - 1)) return
    expandAll()
    move(max + 1, min)
    gridRef.current?.selectRow(min + 1, max + 1)
  })

  // 行編集
  const handleUpdate = useEvent((rowIndex: number, row: GridRow) => {
    // 引数のrowIndexは折り畳みされた後のインデックスなので実際の更新に使うものは別
    const actualRowIndex = getValues('aggregates')?.findIndex(r => r.uniqueId === row.uniqueId)
    if (actualRowIndex !== undefined) {
      update(actualRowIndex, row)
      executeValidate()
    }
  })

  // CHECK。短時間で連続してクエリが発行されるのを防ぐため、一定時間経過後にリクエストを投げる。
  const timeoutHandle = React.useRef<NodeJS.Timeout | undefined>(undefined)
  const [validationErrors, setValidationErrors] = React.useState<ValidationError>({})
  const executeValidate = useEvent(async () => {
    // 直前に処理の予約がある場合はそれをキャンセルする
    if (timeoutHandle.current !== undefined) clearTimeout(timeoutHandle.current)
    // 処理の実行予約を行う
    return new Promise<void>(() => {
      timeoutHandle.current = setTimeout(async () => {
        // 一定時間内に処理がキャンセルされなかった場合のみここの処理が実行される
        const aggregates = getValues('aggregates')
        if (aggregates) setValidationErrors(await validate(getValues('config'), aggregates))
      }, 300)
    })
  })

  // プレビュー（mermaid.jsによるグラフ表示）
  const [, dispatchDialog] = Layout.useDialogContext()
  const showMermaidGraph = useEvent(async () => {
    dispatchDialog(x => x.pushDialog({ title: 'プレビュー', disableConfirm: true }, () => (
      <MermaidPreview getValues={getValues} />
    )))
  })

  // 再読み込み
  const reload = useEvent(async () => {
    reset(await load())
    executeValidate()
  })

  // 保存
  const handleSave = useEvent(async () => {
    if (await save(getValues('config'), fields)) {
      await reload()
    } else {
      executeValidate()
    }
  })

  // 画面初期表示時
  React.useEffect(() => {
    if (ready) reload()
  }, [ready])

  // キーボード操作
  const handleKeyDown: React.KeyboardEventHandler = useEvent(e => {
    console.log('!')
    if (e.key === 'Space') {
    }
  })

  return (
    <ValidationErrorContextProvider value={validationErrors}>
      <PanelGroup direction="vertical" className="w-full h-full p-1">
        <Panel className="flex flex-col gap-1">
          <div className="flex flex-wrap gap-1 items-center">
            <Input.IconButton onClick={showMermaidGraph} icon={Icon.ShareIcon} outline mini>プレビュー</Input.IconButton>
            <div className="basis-2"></div>
            <Input.IconButton onClick={collapseAll} outline mini>折り畳み</Input.IconButton>
            <Input.IconButton onClick={expandAll} outline mini>展開</Input.IconButton>
            <div className="basis-2"></div>
            <Input.IconButton onClick={insertRows} outline mini>挿入</Input.IconButton>
            <Input.IconButton onClick={insertRowsBelow} outline mini>下挿入</Input.IconButton>
            <Input.IconButton onClick={removeRows} outline mini>行削除</Input.IconButton>
            <div className="basis-2"></div>
            <Input.IconButton onClick={handleIncreaseIndent} icon={Icon.ChevronDoubleLeftIcon} outline mini>インデント上げ</Input.IconButton>
            <Input.IconButton onClick={handleDecreaseIndent} icon={Icon.ChevronDoubleRightIcon} outline mini>インデント下げ</Input.IconButton>
            <div className="basis-2"></div>
            <Input.IconButton onClick={handleMoveAbove} icon={Icon.ChevronDoubleUpIcon} outline mini>上移動</Input.IconButton>
            <Input.IconButton onClick={handleMoveBelow} icon={Icon.ChevronDoubleDownIcon} outline mini>下移動</Input.IconButton>
            <div className="flex-1"></div>
            <Input.IconButton onClick={reload} icon={Icon.ArrowPathIcon} outline mini>再読み込み</Input.IconButton>
            <Input.IconButton onClick={openAppSettingDialog} icon={Icon.Cog6ToothIcon} outline mini>設定</Input.IconButton>
            <Input.IconButton onClick={handleSave} icon={Icon.BookmarkSquareIcon} fill mini>保存</Input.IconButton>
          </div>

          <Util.InlineMessageList />

          {/* 選択中の行の情報 */}
          <div className="flex flex-wrap gap-1 items-center select-none text-sm">
            {activeRowTreeInfo.map((info, ix) => (
              <React.Fragment key={ix}>
                {ix > 0 && <span className="text-color-5">&gt;</span>}
                <div className="bg-color-3 px-1 rounded-md">
                  <span className="text-color-7">{info.member}</span>
                  <span className="text-color-5">{info.type}</span>
                </div>
              </React.Fragment>
            ))}
            &nbsp;
          </div>

          {/* グリッド */}
          <Layout.DataTable
            ref={gridRef}
            data={expandedRows}
            columns={columns}
            onKeyDown={handleKeyDown}
            onChangeRow={handleUpdate}
            onActiveRowChanged={handleActiveRowChanged}
            showActiveCellBorderAlways
            className="flex-1"
          />
        </Panel>

        <PanelResizeHandle className="h-2" />

        <Panel defaultSize={10} collapsible>
          <ActiveRowErrors activeRowUniqueId={activeRowUniqueId} />
        </Panel>
      </PanelGroup>
    </ValidationErrorContextProvider >
  )
}

const ActiveRowErrors = ({ activeRowUniqueId }: { activeRowUniqueId: GridRow['uniqueId'] | undefined }) => {
  const errors = useValidationErrorContext(activeRowUniqueId)

  return (
    <ul className="h-full w-full flex flex-col overflow-y-auto bg-color-gutter">
      {errors?.map((err, ix) => (
        <li key={ix} className="text-sm text-orange-600">{err}</li>
      ))}
    </ul>
  )
}

const MermaidPreview = ({ getValues }: { getValues: UseFormGetValues<PageState> }) => {
  const { ready, mermaid } = useBackend()
  const [mermaidJsText, setMermaidJsText] = React.useState<string>()
  const reload = useEvent(async (onlyRoot: boolean) => {
    setMermaidJsText(undefined)
    const aggregates = getValues('aggregates')
    if (!aggregates) return
    setMermaidJsText(await mermaid(getValues('config'), aggregates, onlyRoot))
  })

  const divRef = React.useCallback((div: HTMLDivElement | null) => {
    if (div) {
      mermaidEngine.initialize({
        theme: 'base',
        themeVariables: {
          fontFamily: C_STYLE.fontFamily,
          nodeTextColor: '#000000',
          clusterBkg: '#fff4dd',
          nodeBorder: '#cd834c',
          clusterBorder: '#cd834c',
          clusterTextColor: '#000000',
          edgeLabelBackground: '#ffffff',
        },
      })
      mermaidEngine.run({ nodes: [div] })
    }
  }, [])

  React.useEffect(() => {
    if (ready) reload(true)
  }, [ready])

  // 表示オプション
  const [viewType, setViewType] = React.useState<typeof showOptions[0] | undefined>('ルート集約のみ表示')
  const showOptions = React.useMemo(() => [
    'ルート集約のみ表示' as const,
    '子孫集約も表示' as const,
  ], [])
  const textSelector = React.useCallback((opt: string) => {
    return opt
  }, [])
  const handleViewTypeChanged = useEvent((value: typeof showOptions[0] | undefined) => {
    setViewType(value)
    reload(value !== '子孫集約も表示')
  })

  return (
    <div className="flex flex-col h-full">
      <div>
        <Input.Selection
          value={viewType}
          onChange={handleViewTypeChanged}
          options={showOptions}
          textSelector={textSelector}
        />
      </div>
      <div className="flex-1 relative">
        {mermaidJsText && (
          <div ref={divRef} className="mermaid">
            {mermaidJsText}
          </div>
        )}
      </div>
    </div>
  )
}

const C_STYLE: React.CSSProperties = {
  fontFamily: '"Cascadia Mono", "BIZ UDGothic"',
}

const AppAndContextProviders = () => {
  return (
    <div className="w-full h-full" style={C_STYLE}>
      <Util.ToastContextProvider>
        <Util.MsgContextProvider>
          <Layout.DialogContextProvider>
            <App />
            <Util.Toast />
          </Layout.DialogContextProvider>
        </Util.MsgContextProvider>
      </Util.ToastContextProvider>
    </div>
  )
}

export default AppAndContextProviders
