import React, { memo } from 'react'
import useEvent from 'react-use-event-hook'
import { useFieldArray, useWatch } from 'react-hook-form'
import * as Util from './__autoGenerated/util'
import * as Input from './__autoGenerated/input'
import * as Layout from './__autoGenerated/collection'
import { AggregateOrMember, GridRow, PageState } from './types'
import { useBackend } from './useBackend'
import { useColumnDef } from './useColumnDef'
import { useTypeCombo } from './useTypeCombo'

function App() {

  // データ
  const { ready, load, validate, backendDomain, onChangBackendDomain } = useBackend()
  const { registerEx, getValues, reset, control } = Util.useFormEx<PageState>({})
  const { fields, update } = useFieldArray({ name: 'aggregates', control })

  // データ構造の変換を行う。
  // 集約データは、サーバー上では入れ子のツリー構造。
  // クライアント側ではグリッドで取り回ししやすいように深さのプロパティをもったフラットな配列。
  const flattenGridRows = React.useMemo((): GridRow[] => {
    const rootNodes = Util.toTree(fields as PageState['aggregates'] ?? [], {
      getId: agg => agg.uniqueId,
      getChildren: agg => agg.children,
    })
    return Util.flatten(rootNodes)
  }, [fields])

  // データ型の種類
  const editingXmlFilePath = useWatch({ name: 'editingXmlFilePath', control })
  const aggregateOrMemberTypes = useWatch({ name: 'aggregateOrMemberTypes', control })
  const typeCombo = useTypeCombo(aggregateOrMemberTypes, flattenGridRows)

  // 列定義
  const optionalAttributes = useWatch({ name: 'optionalAttributes', control })
  const columns = useColumnDef(optionalAttributes, typeCombo)

  const gridRef = React.useRef<Layout.DataTableRef<GridRow>>(null)

  // 選択中の行の情報
  const [activeRowInfo, setActiveRowInfo] = React.useState<{ member: string, type: string }[]>([])
  const handleActiveRowChanged = useEvent((activeRow?: { getRow: () => GridRow, rowIndex: number }) => {
    if (activeRow) {
      const row = activeRow.getRow()
      const ancestorsAndRow = [...Util.getAncestors(row), row]
      setActiveRowInfo(ancestorsAndRow.map(row => {
        const type = typeCombo.typeComboSource.find(t => t.key === row.item.type)?.displayName ?? row.item.type
        return {
          member: row.item.displayName ?? '',
          type: type ? `（${type}）` : '',
        }
      }))
    } else {
      setActiveRowInfo([])
    }
  })

  // ----------------------
  // イベント

  const reload = useEvent(async () => {
    const initialState = await load()
    reset(initialState)
  })

  const executeValidate = useEvent(async () => {
    const aggregates = restoreFlattenTree(flattenGridRows)
    await validate(aggregates)
  })

  const handleUpdate = useEvent((rowIndex: number, row: GridRow) => {
    let rootNode: GridRow
    if (row.parent) {
      // 更新されたのが子孫要素の場合
      const indexInSiblings = row.parent.children.indexOf(row)
      row.parent.children.splice(indexInSiblings, 1, row)
      rootNode = Util.getAncestors(row)[0]
    } else {
      // 更新されたのがルート要素の場合
      rootNode = row
    }
    const rootNodeIndex = (fields as PageState['aggregates'] ?? []).indexOf(rootNode.item)
    update(rootNodeIndex, { ...rootNode.item })
  })

  React.useEffect(() => {
    if (ready) reload()
  }, [ready])

  return (
    <div className="flex flex-col w-full h-full p-1 gap-1" style={style}>
      <div className="flex gap-1 items-center">
        <label className="flex-1 flex gap-1 items-center">
          バックエンドURL
          <Input.Word value={backendDomain} onChange={onChangBackendDomain} className="flex-1" />
        </label>
        <Input.IconButton onClick={reload}>再読み込み</Input.IconButton>
        <Input.IconButton onClick={executeValidate}>CHECK</Input.IconButton>
      </div>
      <div className="flex gap-1 text-sm items-start">
        <span className="text-color-6">ファイル名：</span>
        <span className="flex-1 select-all">{editingXmlFilePath}</span>
      </div>

      <Util.InlineMessageList />

      {/* 選択中の行の情報 */}
      <div className="flex flex-wrap gap-1 items-center select-none text-sm">
        {activeRowInfo.map((info, ix) => (
          <React.Fragment key={ix}>
            {ix > 0 && <span className="text-color-5">&gt;</span>}
            <div className="bg-color-3 px-1 rounded-md">
              <span className="text-color-7">{info.member}</span>
              <span className="text-color-5">{info.type}</span>
            </div>
          </React.Fragment>
        ))}
        &nbsp;
      </div>

      {/* グリッド */}
      <Layout.DataTable
        ref={gridRef}
        data={flattenGridRows}
        columns={columns}
        onChangeRow={handleUpdate}
        onActiveRowChanged={handleActiveRowChanged}
        className="flex-1"
      />
    </div>
  )
}

const style: React.CSSProperties = {
  fontFamily: '"Cascadia Mono", "BIZ UDGothic"',
}

const AppAndContextProviders = () => {
  return (
    <Util.MsgContextProvider>
      <Layout.DialogContextProvider>
        <App />
      </Layout.DialogContextProvider>
    </Util.MsgContextProvider>
  )
}

export default AppAndContextProviders


/** Util.toTree の逆の操作 */
const restoreFlattenTree = (flattenGridRows: GridRow[]): AggregateOrMember[] => {
  // depthを正として親を決める。
  // 並び順でより上の方にある行のうち、直近のdepthが浅い行が親。
  const rootAggregates: AggregateOrMember[] = []
  const rowAndChildren = new Map(flattenGridRows.map(row => [row.item, [] as AggregateOrMember[]]))
  for (let rowIndex = flattenGridRows.length - 1; rowIndex >= 0; rowIndex--) {
    const row = flattenGridRows[rowIndex]
    let currentIndex = rowIndex - 1
    while (true) {
      if (currentIndex < 0) {
        rootAggregates.push(row.item)
        break
      }
      const maybeParent = flattenGridRows[currentIndex]
      if (maybeParent.depth < row.depth) {
        rowAndChildren.get(maybeParent.item)?.push(row.item)
        break
      }
      currentIndex--
    }
  }

  // 決まった親子関係をもとにオブジェクトを組み立てる
  const set = (row: AggregateOrMember): AggregateOrMember => {
    const children = rowAndChildren.get(row)?.reverse().map(child => set(child))
    return { ...row, children }
  }
  return rootAggregates
    .reverse()
    .map(row => set(row))
}
