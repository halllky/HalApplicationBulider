import React, { memo } from 'react'
import useEvent from 'react-use-event-hook'
import { useFieldArray, useWatch } from 'react-hook-form'
import * as Icon from '@heroicons/react/24/solid'
import * as Util from './__autoGenerated/util'
import * as Input from './__autoGenerated/input'
import * as Layout from './__autoGenerated/collection'
import { AggregateOrMember, GridRow, PageState } from './types'
import { useBackend } from './useBackend'
import { useColumnDef } from './useColumnDef'
import { useTypeCombo } from './useTypeCombo'
import { useFlattenArrayTree } from './useFlattenArrayTree'
import { useAppSetting } from './useAppSetting'

function App() {

  // データ
  const { ready, load, validate, backendDomain, onChangBackendDomain } = useBackend()
  const { registerEx, getValues, reset, control } = Util.useFormEx<PageState>({})
  const { fields, update } = useFieldArray({ name: 'aggregates', control })
  const fieldsRef = React.useRef<AggregateOrMember[]>()
  fieldsRef.current = fields
  const tree = useFlattenArrayTree(fieldsRef)

  // データ型の種類
  const aggregateOrMemberTypes = useWatch({ name: 'aggregateOrMemberTypes', control })
  const typeCombo = useTypeCombo(aggregateOrMemberTypes, fields, tree)

  // アプリ設定
  const editingXmlFilePath = useWatch({ name: 'editingXmlFilePath', control })
  const { openAppSettingDialog } = useAppSetting(backendDomain, onChangBackendDomain, editingXmlFilePath)

  // 列定義
  const optionalAttributes = useWatch({ name: 'optionalAttributes', control })
  const columns = useColumnDef(optionalAttributes, typeCombo)

  const gridRef = React.useRef<Layout.DataTableRef<GridRow>>(null)

  // 選択中の行の情報
  const [activeRowInfo, setActiveRowInfo] = React.useState<{ member: string, type: string }[]>([])
  const handleActiveRowChanged = useEvent((activeRow?: { getRow: () => GridRow, rowIndex: number }) => {
    if (activeRow) {
      const row = activeRow.getRow()
      const ancestorsAndRow = [...tree.getAncestors(row), row]
      setActiveRowInfo(ancestorsAndRow.map(row => {
        const type = typeCombo.typeComboSource.find(t => t.key === row.type)?.displayName ?? row.type
        return { member: row.displayName ?? '', type: type ? `（${type}）` : '' }
      }))
    } else {
      setActiveRowInfo([])
    }
  })

  // ----------------------
  // イベント

  const reload = useEvent(async () => {
    const initialState = await load()
    reset(initialState)
  })

  const executeValidate = useEvent(async () => {
    await validate(fields)
  })

  React.useEffect(() => {
    if (ready) reload()
  }, [ready])

  return (
    <div className="flex flex-col w-full h-full p-1 gap-1">
      <div className="flex gap-1 items-center">
        <div className="flex-1"></div>
        <Input.IconButton onClick={reload} icon={Icon.ArrowPathIcon} outline mini>再読み込み</Input.IconButton>
        <Input.IconButton onClick={executeValidate} icon={Icon.CheckIcon} outline mini>CHECK</Input.IconButton>
        <Input.IconButton onClick={openAppSettingDialog} icon={Icon.Cog6ToothIcon} outline mini>設定</Input.IconButton>
      </div>

      <Util.InlineMessageList />

      {/* 選択中の行の情報 */}
      <div className="flex flex-wrap gap-1 items-center select-none text-sm">
        {activeRowInfo.map((info, ix) => (
          <React.Fragment key={ix}>
            {ix > 0 && <span className="text-color-5">&gt;</span>}
            <div className="bg-color-3 px-1 rounded-md">
              <span className="text-color-7">{info.member}</span>
              <span className="text-color-5">{info.type}</span>
            </div>
          </React.Fragment>
        ))}
        &nbsp;
      </div>

      {/* グリッド */}
      <Layout.DataTable
        ref={gridRef}
        data={fields}
        columns={columns}
        onChangeRow={update}
        onActiveRowChanged={handleActiveRowChanged}
        className="flex-1"
      />
    </div>
  )
}

const style: React.CSSProperties = {
  fontFamily: '"Cascadia Mono", "BIZ UDGothic"',
}

const AppAndContextProviders = () => {
  return (
    <div className="w-full h-full" style={style}>
      <Util.MsgContextProvider>
        <Layout.DialogContextProvider>
          <App />
        </Layout.DialogContextProvider>
      </Util.MsgContextProvider>
    </div>
  )
}

export default AppAndContextProviders
