using Nijo.Core;
using Nijo.Parts.WebClient;
using Nijo.Util.CodeGenerating;
using Nijo.Util.DotnetEx;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Nijo.Models.ReadModel2Features {
    /// <summary>
    /// 一覧画面
    /// </summary>
    internal class MultiView : IReactPage {
        internal MultiView(GraphNode<Aggregate> agg) {
            _aggregate = agg;
        }
        private readonly GraphNode<Aggregate> _aggregate;

        public string Url => $"/{_aggregate.Item.UniqueId}"; // React Router は全角文字非対応なので
        public string DirNameInPageDir => _aggregate.Item.DisplayName.ToFileNameSafe();
        public string ComponentPhysicalName => $"{_aggregate.Item.PhysicalName}MultiView";
        public bool ShowMenu => true;
        public string? LabelInMenu => _aggregate.Item.DisplayName;

        public SourceFile GetSourceFile() => new SourceFile {
            FileName = "list.tsx",
            RenderContent = context => {
                var searchCondition = new SearchCondition(_aggregate);
                var searchResult = new DataClassForDisplay(_aggregate);
                var loadMethod = new LoadMethod(_aggregate);
                var createView = new SingleView(_aggregate, SingleView.E_Type.New);
                var detailView = new SingleView(_aggregate, SingleView.E_Type.ReadOnly);

                // 新規作成画面へのリンクがあるかどうか
                var linkToCreateView = context.Config.DisableLocalRepository
                    && _aggregate.GetSingleRefKeyAggregate() == null;

                var pageRenderingContext = new ReactPageRenderingContext {
                    Register = "registerExCondition",
                };

                var rowHeader = new DataTableColumn {
                    DataTableRowTypeName = $"AggregateType.{searchResult.TsTypeName}",
                    Id = "col-header",
                    Header = string.Empty,
                    Size = 64,
                    EnableResizing = false,
                    Cell = $$"""
                        cellProps => {
                          const row = cellProps.row.original
                          const state = Util.getLocalRepositoryState(row)
                          const singleViewUrl = Util.{{detailView.GetUrlFnName}}(row.{{DataClassForDisplay.INSTANCE_KEY_TS}})
                          return (
                            <div className="flex items-center gap-1 pl-1">
                              <Link to={singleViewUrl} className="text-link">詳細</Link>
                              <span className="inline-block w-4 text-center">{state}</span>
                            </div>
                          )
                        }
                        """,
                };
                var gridColumns = new[] { rowHeader }.Concat(DataTableColumn.FromMembers(
                    $"AggregateType.{searchResult.TsTypeName}",
                    _aggregate,
                    true,
                    useFormContextType: $"{{ currentPageItems: AggregateType.{searchResult.TsTypeName}[] }}",
                    registerPathModifier: path => $"currentPageItems.${{row.index}}.{path}"));

                return $$"""
                    import React, { useCallback, useEffect, useMemo, useRef, useState, useReducer } from 'react'
                    import { useEvent } from 'react-use-event-hook'
                    import { Link, useLocation } from 'react-router-dom'
                    import { useFieldArray, FormProvider } from 'react-hook-form'
                    import * as Icon from '@heroicons/react/24/outline'
                    import { ImperativePanelHandle, Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels'
                    import * as Util from '../../util'
                    import * as Input from '../../input'
                    import * as Layout from '../../collection'
                    import * as AggregateType from '../../autogenerated-types'
                    import * as AggregateHook from '../../autogenerated-hooks'

                    const VForm = Layout.VerticalForm

                    export default function () {
                      const [, dispatchMsg] = Util.useMsgContext()
                      const [, dispatchToast] = Util.useToastContext()
                      const { get } = Util.useHttpRequest()

                      // 検索条件
                      const [currentPage, dispatchPaging] = useReducer(pagingReducer, { pageIndex: 0 })
                      const rhfSearchMethods = Util.useFormEx<AggregateType.{{searchCondition.TsTypeName}}>({})
                      const {
                        getValues: getConditionValues,
                        registerEx: registerExCondition,
                        reset: resetSearchCondition,
                      } = rhfSearchMethods

                      // 検索結果
                      const { {{LoadMethod.LOAD}}, {{LoadMethod.CURRENT_PAGE_ITEMS}} } =  AggregateHook.{{loadMethod.ReactHookName}}()

                      // 検索条件欄の開閉
                      const searchConditionPanelRef = useRef<ImperativePanelHandle>(null)
                      const [collapsed, setCollapsed] = useState(false)
                      const toggleSearchCondition = useCallback(() => {
                        if (searchConditionPanelRef.current?.getCollapsed()) {
                          searchConditionPanelRef.current.expand()
                        } else {
                          searchConditionPanelRef.current?.collapse()
                        }
                      }, [searchConditionPanelRef])

                      // 初期表示時処理
                      const { search: locationSerach } = useLocation()
                      useEffect(() => {
                        const condition = parseQueryParameter(locationSerach)
                        {{LoadMethod.LOAD}}(condition) // 再検索
                        resetSearchCondition(condition) // 画面上の検索条件欄の表示を更新する
                      }, [{{LoadMethod.LOAD}}, locationSerach])

                      // 再読み込み時処理
                      const handleReload = useCallback(() => {
                        const condition = getConditionValues()
                        {{LoadMethod.LOAD}}(condition) // 再検索
                        resetSearchCondition(condition) // 画面上の検索条件欄の表示を更新する
                        searchConditionPanelRef.current?.collapse() // 検索条件欄を閉じる
                      }, [{{LoadMethod.LOAD}}, getConditionValues, resetSearchCondition, searchConditionPanelRef])

                      // クリア時処理
                      const clearSearchCondition = useCallback(() => {
                        resetSearchCondition()
                        searchConditionPanelRef.current?.expand()
                      }, [resetSearchCondition, searchConditionPanelRef])

                      // 列定義
                      const columnDefs: Layout.ColumnDefEx<AggregateType.{{searchResult.TsTypeName}}>[] = useMemo(() => [
                        {{WithIndent(gridColumns.SelectTextTemplate(col => col.Render()), "    ")}}
                      ], [get])


                      return (
                        <Layout.PageFrame
                          header={<>
                            <Layout.PageTitle className="self-center">
                              {{_aggregate.Item.DisplayName}}
                            </Layout.PageTitle>
                    {{If(linkToCreateView, () => $$"""
                            <Link to={Util.{{createView.GetUrlFnName}}()} className="self-center">新規作成</Link>
                    """)}}
                            <div className="flex-1"></div>
                            <Input.IconButton className="self-center" onClick={clearSearchCondition}>クリア</Input.IconButton>
                            <div className="self-center flex">
                              <Input.IconButton icon={Icon.MagnifyingGlassIcon} fill onClick={handleReload}>検索</Input.IconButton>
                              <div className="self-stretch w-px bg-color-base"></div>
                              <Input.IconButton icon={collapsed ? Icon.ChevronDownIcon : Icon.ChevronUpIcon} fill onClick={toggleSearchCondition} hideText>検索条件</Input.IconButton>
                            </div>
                          </>}
                        >

                          <PanelGroup direction="vertical">

                            {/* 検索条件欄 */}
                            <Panel ref={searchConditionPanelRef} defaultSize={30} collapsible onCollapse={setCollapsed}>
                              <div className="h-full overflow-auto">
                                <FormProvider {...rhfSearchMethods}>
                                  <VForm.Container estimatedLabelWidth="10rem" className="p-1">
                                    {{WithIndent(searchCondition.RenderVFormBody(pageRenderingContext), "                ")}}
                                  </VForm.Container>
                                </FormProvider>
                              </div>
                            </Panel>

                            <PanelResizeHandle className="h-2 bg-color-4" />

                            {/* 検索結果欄 */}
                            <Panel>
                              <Util.InlineMessageList />
                              <Layout.DataTable
                                data={{{LoadMethod.CURRENT_PAGE_ITEMS}}}
                                columns={columnDefs}
                                className="h-full"
                              ></Layout.DataTable>
                            </Panel>
                          </PanelGroup>

                        </Layout.PageFrame>
                      )
                    }

                    /** クエリパラメータを解釈して画面初期表示時検索条件オブジェクトを返します。 */
                    function parseQueryParameter(url: string): AggregateType.{{searchCondition.TsTypeName}} {
                      const searchParams = new URLSearchParams(new URL(url).search)
                      const searchCondition = AggregateType.{{searchCondition.CreateNewObjectFnName}}()

                      // 初期表示時検索条件の解釈（フィルタ）
                    {{searchCondition.EnumerateFilterMembersRecursively().SelectTextTemplate(m => $$"""
                      if (searchParams.has('{{m.Member.Declared.GetFullPathAsSearchConditionFilter(E_CsTs.TypeScript).Join(".")}}'))
                        searchCondition.{{m.Member.Declared.GetFullPathAsSearchConditionFilter(E_CsTs.TypeScript).Join(".")}} = searchParams.get('{{m.Member.Declared.GetFullPathAsSearchConditionFilter(E_CsTs.TypeScript).Join(".")}}')!
                    """)}}

                      // 初期表示時検索条件の解釈（ソート）
                      let i = 0
                      while (true) {
                        const sortOrder = searchParams.get({{QueryParamSort("i")}})
                        if (sortOrder == null) break
                        searchCondition.{{SearchCondition.SORT_TS}}.push(sortOrder as AggregateType.{{searchCondition.TsTypeName}}['{{SearchCondition.SORT_TS}}'][0])
                        i++
                      }

                      return searchCondition
                    }

                    // TODO: utilに持っていく
                    type PageState = { pageIndex: number, loaded?: boolean }
                    const pagingReducer = Util.defineReducer((state: PageState) => ({
                      loadComplete: () => ({ pageIndex: state.pageIndex, loaded: true }),
                      nextPage: () => ({ pageIndex: state.pageIndex + 1, loaded: false }),
                      prevPage: () => ({ pageIndex: Math.max(0, state.pageIndex - 1), loaded: false }),
                      moveTo: (pageIndex: number) => ({ pageIndex, loaded: false }),
                    }))
                    """;
            },
        };

        internal string NavigationHookName => $"useNavigateTo{_aggregate.Item.PhysicalName}MultiView";

        internal string RenderNavigationHook(CodeRenderingContext context) {
            var searchCondition = new SearchCondition(_aggregate);
            return $$"""
                /** {{_aggregate.Item.DisplayName}}の一覧検索画面へ遷移します。初期表示時検索条件を指定することができます。 */
                export const {{NavigationHookName}} = () => {
                  const navigate = ReactRouter.useNavigate()

                  /** {{_aggregate.Item.DisplayName}}の一覧検索画面へ遷移します。初期表示時検索条件を指定することができます。 */
                  return React.useCallback((initialSearchCondition?: Types.{{searchCondition.TsTypeName}}) => {
                    // 初期表示時検索条件の設定（フィルタ）
                    const searchParams = new URLSearchParams()
                {{searchCondition.EnumerateFilterMembersRecursively().SelectTextTemplate(m => $$"""
                    if (initialSearchCondition?.{{m.Member.Declared.GetFullPathAsSearchConditionFilter(E_CsTs.TypeScript).Join("?.")}} !== undefined)
                      searchParams.append('{{m.Member.Declared.GetFullPathAsSearchConditionFilter(E_CsTs.TypeScript).Join(".")}}', initialSearchCondition.{{m.Member.Declared.GetFullPathAsSearchConditionFilter(E_CsTs.TypeScript).Join(".")}})
                """)}}

                    // 初期表示時検索条件の設定（ソート）
                    if (initialSearchCondition !== undefined) {
                      for (let i = 0; i < initialSearchCondition.{{SearchCondition.SORT_TS}}.length; i++) {
                        searchParams.append({{QueryParamSort("i")}}, initialSearchCondition.{{SearchCondition.SORT_TS}}[i])
                      }
                    }

                    navigate({
                      pathname: '{{Url}}',
                      search: searchParams.toString()
                    })
                  }, [navigate])
                }
                """;
        }

        /// <summary>
        /// JavaScriptのURLSearchParamsクラスに設定するソートの値のキー名
        /// </summary>
        private static string QueryParamSort(string i) {
            return $"`SORT.${{{i}}}`";
        }
    }
}
