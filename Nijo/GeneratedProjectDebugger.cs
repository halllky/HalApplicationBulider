using Nijo.Util.DotnetEx;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace Nijo {
    public sealed partial class GeneratedProjectDebugger {
        internal GeneratedProjectDebugger(GeneratedProject project, ILogger? log) {
            _project = project;
            _log = log;
        }

        private readonly GeneratedProject _project;
        private readonly ILogger? _log;

        /// <summary>
        /// デバッグを開始します。
        /// </summary>
        public async Task StartDebugging(CancellationToken cancellationToken) {

            // 以下の3種類のキャンセルがあるので統合する
            // - ユーザーの操作によるデバッグプロセス全体のキャンセル
            // - 集約定義ファイル更新によるビルドのキャンセル
            // - dotnet run のキャンセル
            CancellationTokenSource? rebuildCancellation = null;
            CancellationTokenSource? dotnetRunCancellation= null;
            CancellationTokenSource? cancelIfAbortOrReuild = null;
            CancellationTokenSource? cancelIfAbortOrStopRunning = null;

            // バックグラウンド処理の宣言
            Task? dotnetRun = null;
            Task? npmStart = null;

            // ファイル変更監視用オブジェクト
            FileSystemWatcher? watcher = null;

            try {
                _log?.LogInformation("デバッグを開始します。");

                var changed = false;
                var clientUrl = GetDebuggingClientUrl();
                var serverUrl = GetDebugUrl();

                watcher = new FileSystemWatcher(_project.ProjectRoot);
                watcher.Filter = Path.GetFileName(_project.SchemaXml.GetPath());
                watcher.NotifyFilter = NotifyFilters.LastWrite;
                watcher.Changed += (_, _) => {
                    changed = true;
                    rebuildCancellation?.Cancel();
                };
                watcher.EnableRaisingEvents = true;

                npmStart = await _project.Debugger.CreateClientRunningProcess(cancellationToken);

                // リビルドの度に実行される処理
                while (true) {
                    if (_project.ValidateSchema(out var errors)) {
                        // 既に実行されている処理のキャンセル
                        if (dotnetRun != null) {
                            _log?.LogInformation("dotnetプロセスの終了を待機します。");
                            dotnetRunCancellation?.Cancel();
                            dotnetRun.Wait();
                            dotnetRun.Dispose();
                            _log?.LogInformation("dotnetプロセスを終了しました。");
                        }
                        rebuildCancellation?.Dispose();
                        dotnetRunCancellation?.Dispose();
                        cancelIfAbortOrReuild?.Dispose();
                        cancelIfAbortOrStopRunning?.Dispose();

                        rebuildCancellation = new CancellationTokenSource();
                        dotnetRunCancellation = new CancellationTokenSource();
                        cancelIfAbortOrReuild = CancellationTokenSource.CreateLinkedTokenSource(
                            cancellationToken,
                            rebuildCancellation.Token);
                        cancelIfAbortOrStopRunning = CancellationTokenSource.CreateLinkedTokenSource(
                            cancellationToken,
                            dotnetRunCancellation.Token);

                        try {
                            // ソースファイル再生成
                            _project.CodeGenerator.UpdateAutoGeneratedCode();

                            // ビルド
                            await BuildAsync(cancelIfAbortOrReuild.Token, E_NpmBuild.None);

                            // 実行
                            dotnetRun = await CreateServerRunningProcess(cancelIfAbortOrStopRunning.Token);

                            //// DB再作成
                            //_log?.LogInformation("DBを削除して再作成します。");
                            //using var client = new HttpClient();
                            //var uri = new Uri(GetDebugUrl(), Features.WebClient.DebuggerController.RECREATE_DB_URL);
                            //var message = new HttpRequestMessage(HttpMethod.Post, uri);
                            //var httpResponse = await client.SendAsync(message, cancelIfAbortOrReuild.Token);
                            //if (!httpResponse.IsSuccessStatusCode) {
                            //    var errorContent = await httpResponse.Content.ReadAsStringAsync(cancelIfAbortOrReuild.Token);
                            //    _log?.LogInformation("DBの削除・再作成でエラーが発生しました: {ErrorContent}", errorContent);
                            //}

                            _log?.LogInformation("アプリケーション実行中...");
                            _log?.LogInformation("CLIENT: {Url}", clientUrl);
                            _log?.LogInformation("SERVER: {Url}", serverUrl);

                        } catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested) {
                            throw; // デバッグ自体を中断

                        } catch (OperationCanceledException) when (rebuildCancellation.IsCancellationRequested) {
                            continue; // 実行中のビルドを中断してもう一度最初から

                        } catch (Exception ex) {
                            _log?.LogCritical(ex, "デバッグ中にエラーが発生しました。");
                        }

                    } else {
                        _log?.LogWarning("アプリケーション定義が不正です。\r\n{Errors}", errors.Join(Environment.NewLine));
                    }

                    changed = false;

                    // 次の更新まで待機
                    while (changed == false) {
                        await Task.Delay(100, cancellationToken);
                        cancellationToken.ThrowIfCancellationRequested();
                    }
                }

            } catch (OperationCanceledException) {
                _log?.LogInformation("デバッグを中断します。");

            } finally {
                watcher?.Dispose();

                if (npmStart != null) {
                    _log?.LogInformation("npmプロセスの終了を待機します。");
                    npmStart.Wait();
                    npmStart.Dispose();
                    _log?.LogInformation("npmプロセスを終了しました。");
                }
                if (dotnetRun != null) {
                    _log?.LogInformation("dotnetプロセスの終了を待機します。");
                    dotnetRun.Wait();
                    dotnetRun.Dispose();
                    _log?.LogInformation("dotnetプロセスを終了しました。");
                }

                rebuildCancellation?.Dispose();
                cancelIfAbortOrReuild?.Dispose();
                cancelIfAbortOrStopRunning?.Dispose();
            }
        }

        /// <summary>
        /// クライアントサイドプロセスのコマンドを作成します。
        /// </summary>
        internal Task<Task> CreateClientRunningProcess(CancellationToken cancellationToken) {
            return _project.ClientDirTerminal.RunBackground(new[] { "npm", "run", "dev" }, ViteReadyConsole(), cancellationToken);
        }
        /// <summary>
        /// サーバーサイドプロセスのコマンドを作成します。
        /// ビルドは行いません。
        /// 実行中のソースファイルの変更は自動的に反映されません。
        /// </summary>
        internal Task<Task> CreateServerRunningProcess(CancellationToken cancellationToken) {
            return _project.WebapiDirTerminal.RunBackground(new[] { "dotnet", "run", "--no-build", "--launch-profile", "https" }, AspCoreStartedRegex(), cancellationToken);
        }

        /// <summary>
        /// デバッグ時に起動されるアプリケーションのURLを返します。
        /// </summary>
        public Uri GetDebugUrl() {
            return new Uri(GetDebuggingServerUrl().Split(';')[0]);
        }
        /// <summary>
        /// デバッグ時に起動されるSwagger UIのURLを返します。
        /// </summary>
        /// <returns></returns>
        public Uri GetSwaggerUrl() {
            return new Uri(new Uri(GetDebuggingServerUrl().Split(';')[0]), "swagger");
        }
        /// <summary>
        /// launchSettings.jsonのhttpsプロファイルのapplicationUrlセクションの値を読み取ります。
        /// </summary>
        private string GetDebuggingServerUrl() {
            var properties = Path.Combine(_project.WebApiProjectRoot, "Properties");
            if (!Directory.Exists(properties)) throw new DirectoryNotFoundException(properties);
            var launchSettings = Path.Combine(properties, "launchSettings.json");
            if (!File.Exists(launchSettings)) throw new FileNotFoundException(launchSettings);

            var json = File.ReadAllText(launchSettings);
            var obj = JsonSerializer.Deserialize<JsonObject>(json);
            if (obj == null)
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (!obj.TryGetPropertyValue("profiles", out var profiles))
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (profiles == null)
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (!profiles.AsObject().TryGetPropertyValue("https", out var https))
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (https == null)
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (!https.AsObject().TryGetPropertyValue("applicationUrl", out var applicationUrl))
                throw new InvalidOperationException($"Invalid json: {launchSettings}");
            if (applicationUrl == null)
                throw new InvalidOperationException($"Invalid json: {launchSettings}");

            return applicationUrl.GetValue<string>();
        }
        /// <summary>
        /// vite.config.ts からポートを参照してURLを生成して返します。
        /// </summary>
        /// <returns></returns>
        public Uri GetDebuggingClientUrl() {
            var viteConfigTs = Path.Combine(_project.WebClientProjectRoot, "vite.config.ts");
            if (!File.Exists(viteConfigTs))
                throw new FileNotFoundException(viteConfigTs);

            using var stream = new StreamReader(viteConfigTs, Encoding.UTF8);
            var regex = new Regex(@"port:\s*([^,]*)");
            while (!stream.EndOfStream) {
                var line = stream.ReadLine();
                if (line == null) continue;
                var match = regex.Match(line);
                if (!match.Success) continue;
                var port = match.Groups[1].Value;
                return new Uri($"http://localhost:{port}");
            }

            throw new InvalidOperationException("vite.config.ts からポート番号を読み取れません。'port: 9999'のようにポートを設定している行があるか確認してください。");
        }

        /// <summary>
        /// 必要なnpmモジュールをインストールします。
        /// </summary>
        public GeneratedProjectDebugger InstallDependencies() {
            _project.ClientDirTerminal
                .Run(new[] { "npm", "ci" }, CancellationToken.None)
                .Wait();

            // dotnetはビルド時に自動的にインストールされるので何もしない

            return this;
        }

        /// <summary>
        /// プロジェクトをビルドします。
        /// </summary>
        /// <param name="npm">npmのビルドをどうするか</param>
        public async Task BuildAsync(CancellationToken cancellationToken, E_NpmBuild npm) {
            var dotnetBuild = _project.WebapiDirTerminal.Run(new[] { "dotnet", "build" }, cancellationToken);
            var npmBuild = npm switch {
                E_NpmBuild.Build => _project.ClientDirTerminal.Run(new[] { "npm", "run", "build" }, cancellationToken),
                E_NpmBuild.OnlyCompilerCheck => _project.ClientDirTerminal.Run(new[] { "npm", "run", "tsc" }, cancellationToken),
                _ => Task.CompletedTask,
            };

            await Task.WhenAll(dotnetBuild, npmBuild);
        }
        public enum E_NpmBuild {
            Build,
            OnlyCompilerCheck,
            None,
        }

        [GeneratedRegex("Now listening on:")]
        private static partial Regex AspCoreStartedRegex();
        [GeneratedRegex("➜")]
        private static partial Regex ViteReadyConsole();
    }
}
