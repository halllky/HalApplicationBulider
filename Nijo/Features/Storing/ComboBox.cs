using Nijo.Core;
using Nijo.Util.DotnetEx;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Nijo.Util.CodeGenerating;

namespace Nijo.Features.Storing {
    internal class ComboBox {
        internal ComboBox(GraphNode<Aggregate> aggregate) {
            _aggregate = aggregate;
        }

        private readonly GraphNode<Aggregate> _aggregate;

        internal string ComponentName => $"ComboBox{_aggregate.Item.DisplayName.ToCSharpSafe()}";
        internal string Api => new KeywordSearchingFeature(_aggregate).GetUri();

        internal static SourceFile RenderDeclaringFile(CodeRenderingContext ctx) => new SourceFile {
            FileName = "AggregateComboBox.tsx",
            RenderContent = context => $$"""
                import React, { useState, useMemo, useCallback, useRef, useImperativeHandle } from "react"
                import * as Util from "../util"
                import { defineCustomComponent, AsyncComboBox, CustomComponentRef } from "../input"
                import * as Types from "../autogenerated-types"

                {{ctx.Schema
                    .AllAggregates()
                    .Where(a => a.GetRoot().Item.Options.Handler == NijoCodeGenerator.Models.WriteModel.Key)
                    .SelectTextTemplate(a => new ComboBox(a).Render())}}
                """,
        };

        private string Render() {
            var combo = new ComboBox(_aggregate);
            var keyArray = KeyArray.Create(_aggregate.AsEntry());
            var keyName = new TransactionScopeRefTargetClass(_aggregate);
            var names = keyName
                .GetOwnMembers()
                .OfType<AggregateMember.ValueMember>()
                .Select(vm => vm.Declared.GetFullPath().Join("?."));

            return $$"""
                export const {{combo.ComponentName}} = defineCustomComponent<Util.ItemKey>((props, ref) => {
                  type ComboItem = { key: Util.ItemKey, item?: Types.{{keyName.TypeScriptTypeName}} }

                  const [queryKey, setQueryKey] = useState<string>('combo-{{_aggregate.Item.UniqueId}}::')
                  const { get } = Util.useHttpRequest()
                  const query = useCallback(async (keyword: string | undefined): Promise<ComboItem[]> => {
                    setQueryKey(`combo-{{_aggregate.Item.UniqueId}}::${keyword ?? ''}`)
                    const response = await get<Types.{{keyName.TypeScriptTypeName}}[]>(`{{combo.Api}}`, { keyword })
                    if (!response.ok) return []
                    return response.data.map(item => ({
                      key: JSON.stringify([{{keyArray.Select(k => $"item.{k.Member.Declared.GetFullPath().Join("?.")}").Join(", ")}}]) as Util.ItemKey,
                      item,
                    }))
                  }, [get])

                  const { value, onChange, ...rest } = props
                  const value2 = useMemo<ComboItem | undefined>(() => {
                    return value ? { key: value } : undefined
                  }, [value])
                  const onChange2 = useCallback((value: ComboItem | undefined) => {
                    onChange?.(value?.key)
                  }, [onChange])

                  const ref2 = useRef<CustomComponentRef<ComboItem>>(null)
                  useImperativeHandle(ref, () => ({
                    focus: () => ref2.current?.focus(),
                    getValue: () => ref2.current?.getValue()?.key,
                  }))

                  return (
                    <AsyncComboBox
                      {...rest}
                      value={value2}
                      onChange={onChange2}
                      ref={ref2}
                      queryKey={queryKey}
                      query={query}
                      keySelector={({ key }) => key}
                      textSelector={({ key, item }) => `{{names.Select(path => $"${{item?.{path} ?? ''}}").Join(string.Empty)}}` || key}
                    />
                  )
                })
                """;
        }

        internal string RenderCaller(string raectHookFormId, params string[] attrs) {
            var attributes = attrs
                .Where(str => !string.IsNullOrWhiteSpace(str))
                .Join(" ");
            return $$"""
                <Input.{{ComponentName}} {...registerEx({{raectHookFormId}})} {{attributes}} />
                """;
        }
    }
}
