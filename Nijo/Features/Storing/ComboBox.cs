using Nijo.Core;
using Nijo.Util.DotnetEx;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Nijo.Util.CodeGenerating;

namespace Nijo.Features.Storing {
    internal class ComboBox {
        internal ComboBox(GraphNode<Aggregate> aggregate) {
            _aggregate = aggregate;
        }

        private readonly GraphNode<Aggregate> _aggregate;

        internal string ComponentName => $"ComboBox{_aggregate.Item.DisplayName.ToCSharpSafe()}";
        internal string Api => new KeywordSearchingFeature(_aggregate).GetUri();

        internal static SourceFile RenderDeclaringFile(CodeRenderingContext ctx) => new SourceFile {
            FileName = "AggregateComboBox.tsx",
            RenderContent = context => $$"""
                import React, { useState, useMemo, useCallback, useRef, useImperativeHandle } from "react"
                import * as Util from "../util"
                import { defineCustomComponent, AsyncComboBox, CustomComponentRef } from "../input"
                import * as Types from "../autogenerated-types"

                {{ctx.Schema
                    .AllAggregates()
                    .Where(a => a.GetRoot().Item.Options.Handler == NijoCodeGenerator.Models.WriteModel.Key)
                    .SelectTextTemplate(a => new ComboBox(a).Render())}}
                """,
        };

        private string Render() {
            var combo = new ComboBox(_aggregate);
            var refInfo = new DataClassForDisplayRefTarget(_aggregate);
            var names = _aggregate
                .AsEntry()
                .GetNames()
                .OfType<AggregateMember.ValueMember>();

            return $$"""
                export const {{combo.ComponentName}} = defineCustomComponent<Types.{{refInfo.TsTypeName}}>((props, ref) => {
                  const [queryKey, setQueryKey] = useState<string>({{RenderReactQueryKeyString()}})
                  const { get } = Util.useHttpRequest()
                  const query = useCallback(async (keyword: string | undefined): Promise<Types.{{refInfo.TsTypeName}}[]> => {
                    setQueryKey({{RenderReactQueryKeyString("keyword")}})
                    const response = await get<Types.{{refInfo.TsTypeName}} []>(`{{combo.Api}}`, { keyword })
                    if (!response.ok) return []
                    return response.data
                  }, [get])

                  return (
                    <AsyncComboBox
                      {...props}
                      ref={ref}
                      queryKey={queryKey}
                      query={query}
                      emitValueSelector={item => item}
                      matchingKeySelectorFromEmitValue={item => item.{{DataClassForDisplayRefTarget.INSTANCE_KEY}}}
                      matchingKeySelectorFromOption={item => item.{{DataClassForDisplayRefTarget.INSTANCE_KEY}}}
                      textSelector={item => `{{names.Select(n => $"${{item.{n.Declared.GetFullPathAsDisplayRefTargetClass().Join("?.")} ?? ''}}").Join("")}}`}
                    />
                  )
                })
                """;
        }

        /// <summary>
        /// React Query でキャッシュや最適化を行うために、同一のクエリごとに設定するキー
        /// </summary>
        internal string RenderReactQueryKeyString(string? keywordVarName = null) {
            return keywordVarName == null
                ? $"`combo-{_aggregate.Item.UniqueId}::`"
                : $"`combo-{_aggregate.Item.UniqueId}::${{{keywordVarName} ?? ''}}`";
        }

        internal string RenderCaller(string raectHookFormId, params string[] attrs) {
            var attributes = attrs
                .Where(str => !string.IsNullOrWhiteSpace(str))
                .Join(" ");
            return $$"""
                <Input.{{ComponentName}} {...registerEx({{raectHookFormId}})} {{attributes}} />
                """;
        }
    }
}
