using Nijo.Core;
using Nijo.Parts.WebServer;
using Nijo.Util.CodeGenerating;
using Nijo.Util.DotnetEx;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Nijo.Features.BatchUpdate {
    partial class BatchUpdateFeature {
        #region TypeScript側のヘルパー
        private static SourceFile TsHelper(CodeRenderingContext context) {
            var availableAggregates = GetAvailableAggregates(context);

            return new SourceFile {
                FileName = "useBatchUpdate.ts",
                RenderContent = context => $$"""
                    import { useCallback } from 'react'
                    import { useFieldArray } from 'react-hook-form'
                    import * as Types from '../autogenerated-types'
                    import { useHttpRequest } from './Http'
                    import { useFormEx } from './ReactHookFormUtil'
                    import { useMsgContext } from './Notification'
                    import * as Storage from './Storage'

                    export type BatchUpdateState = {
                      items: BatchUpdateItem[]
                    }
                    export type BatchUpdateItem
                    {{availableAggregates.SelectTextTemplate((agg, i) => $$"""
                      {{(i == 0 ? "=" : "|")}} { type: '{{GetKey(agg)}}', act: ActionType, item: Types.{{agg.Item.TypeScriptTypeName}} }
                    """)}}
                    export type ActionType = 'a' | 'm' | 'd' // add, modify, delete

                    export default () => {
                      // react-hook-formとのつなぎこみ
                      const useFormExReturnValues = useFormEx<BatchUpdateState>({})
                      const useFieldArrayReturnValues = useFieldArray({
                        name: 'items',
                        control: useFormExReturnValues.control,
                      })

                      // 一時保存
                      const { data: unComittedData, save: saveTemporary } = useUncomitted()

                      // 一括更新処理のスケジューリング
                      const [, dispatchMsg] = useMsgContext()
                      const { post } = useHttpRequest()
                      const executeBatchUpdate = useCallback(async () => {
                        const groups = groupBy(useFormExReturnValues.getValues('items'), x => x.type)
                        for (const group of groups) {
                          const url = `/{{BackgroundService.BgTaskFeature.GetScheduleApiURL(context)}}/{{JOBKEY}}`
                          const param = {
                            DataType: group[0],
                            Items: group[1].map(({ act, item }) => ({
                              Action: (act === 'a' ? 'Add' : (act === 'd' ? 'Delete' : 'Modify')),
                              Data: item,
                            })),
                          }
                          const res = await post(url, param)
                          if (res.ok) dispatchMsg(msg => msg.info(`${group[0]}の更新をスケジューリングしました。`))
                        }
                      }, [post, useFormExReturnValues.handleSubmit, useFormExReturnValues.getValues])
                    
                      return {
                        items: useFieldArrayReturnValues.fields,
                        addNewItem: useFieldArrayReturnValues.append,
                        executeBatchUpdate,
                        unComittedData,
                        saveTemporary,
                        rawApi: {
                          ...useFormExReturnValues,
                          ...useFieldArrayReturnValues,
                        },
                      }
                    }

                    const [UnComittedCacheProvider, useUncomitted] = Storage.defineStorageContext({
                      storageKey: 'NIJO::UNCOMITTED',
                      defaultValue: (): BatchUpdateState => ({ items: [] }),
                      serialize: obj => JSON.stringify(obj),
                      deserialize: str => JSON.parse(str),
                      noMessageOnSave: true,
                    })

                    const groupBy = <TItem, TKey>(arr: TItem[], fn: (t: TItem) => TKey): Map<TKey, TItem[]> => {
                      return arr.reduce((map, curr) => {
                        const key = fn(curr)
                        const group = map.get(key)
                        if (group) {
                          group.push(curr)
                        } else {
                          map.set(key, [curr])
                        }
                        return map
                      }, new Map<TKey, TItem[]>())
                    }
                    """,
            };
        }
        #endregion TypeScript側のヘルパー


        #region C#側のヘルパー
        private static SourceFile RenderParamBuilder(CodeRenderingContext context) {
            var appSrv = new ApplicationService();
            var availableAggregates = GetAvailableAggregates(context).ToArray();

            return new SourceFile {
                FileName = "BatchUpdateTask_Helper.cs",
                RenderContent = context => $$"""
                    namespace {{context.Config.RootNamespace}} {
                        {{WithIndent(availableAggregates.SelectTextTemplate(RenderParamBuilder), "    ")}}
                    }
                    """,
            };
        }
        private static string RenderParamBuilder(GraphNode<Aggregate> agg) {
            var className = $"{agg.Item.ClassName}BatchUpdateParameter";
            var create = new Features.Storing.CreateFeature(agg);
            var update = new Features.Storing.UpdateFeature(agg);
            var delKeys = KeyArray.Create(agg);

            return $$"""

                /// <summary>
                /// <see cref="BatchUpdateParameter" /> に静的型がついていないのを補完して使いやすくするためのクラス
                /// </summary>
                public class {{className}} {
                    private readonly List<BatchUpdateData> _data = new();

                    public {{className}} Add({{create.ArgType}} cmd) {
                        _data.Add(new BatchUpdateData { Action = E_BatchUpdateAction.Add, Data = cmd });
                        return this;
                    }
                    public {{className}} Modify({{update.ArgType}} item) {
                        _data.Add(new BatchUpdateData { Action = E_BatchUpdateAction.Modify, Data = item });
                        return this;
                    }
                    public {{className}} Delete({{delKeys.Select(k => $"{k.CsType} {k.VarName}").Join(", ")}}) {
                        _data.Add(new BatchUpdateData { Action = E_BatchUpdateAction.Delete, Data = new object[] { {{delKeys.Select(k => k.VarName).Join(", ")}} } });
                        return this;
                    }
                    public BatchUpdateParameter Build() => new BatchUpdateParameter {
                        DataType = "{{GetKey(agg)}}",
                        Items = _data.ToList(),
                    };
                }
                """;
        }
        #endregion C#側のヘルパー
    }
}
