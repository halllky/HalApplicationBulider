import { useMemo } from 'react'
import { QueryClient, QueryClientProvider } from 'react-query'
import { useFieldArray } from 'react-hook-form'
import * as Util from '../__autoGenerated/util'
import * as Layout from '../__autoGenerated/collection'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
      refetchOnWindowFocus: false,
    },
  },
})

export default function () {

  const { control, getValues } = Util.useFormEx<{ gridItems: DisplayData[] }>({
    defaultValues: () => Promise.resolve({ gridItems: getDefaultData() }),
  })
  const { fields, update } = useFieldArray({ control, name: 'gridItems' })
  const columnDef = useMemo(() => {
    return getColumnDef()
  }, [])

  return (
    <QueryClientProvider client={queryClient}>
      <div className="h-full flex flex-col gap-2 justify-start items-start p-2">
        <Layout.DataTable
          data={fields}
          columns={columnDef}
          onChangeRow={update}
          className="flex-1 self-stretch"
        />
        <textarea
          readOnly
          value={JSON.stringify(getValues('gridItems'), undefined, '  ')}
          className="flex-1 self-stretch border border-1 border-color-2"
        />
      </div>
    </QueryClientProvider>
  )
}


type DirtyValue = string
type FormattedNumberString = string
type RefInfo = { k: string, t: string }

type DisplayData = {
  strValue?: string
  numValue?: FormattedNumberString // | DirtyValue // TODO
  enmValue?: RefInfo // | DirtyValue // TODO
  refValue?: RefInfo // | DirtyValue // TODO
}
type SaveCommand = {
  strValue?: string
  numValue?: number
  refValue?: { key: string }
}
const DROPDOWN_OPTIONS: RefInfo[] = [
  { k: 'a', t: 'あ' },
  { k: 'i', t: 'い' },
  { k: 'u', t: 'う' },
]
const getDefaultData = (): DisplayData[] => [
  { strValue: 'THIS IS STRING VALUE.', numValue: '123456789', refValue: { ...DROPDOWN_OPTIONS[1] } },
  {},
]
const getColumnDef = (): Layout.DataTableColumn<DisplayData>[] => [
  {
    id: 'col0',
    header: 'strValue',
    render: row => row.strValue,
    onClipboardCopy: row => row.strValue ?? '',
    editSetting: {
      type: 'text',
      onStartEditing: row => row.strValue,
      onEndEditing: (row, value) => { row.strValue = value },
      onClipboardPaste: (row, value) => { row.strValue = value },
    },
  },
  {
    id: 'col1',
    header: 'numValue',
    headerGroupName: '属性項目',
    render: row => row.numValue,
    onClipboardCopy: row => row.numValue?.toString() ?? '',
    editSetting: {
      type: 'text',
      onStartEditing: row => row.numValue,
      onEndEditing: (row, value) => {
        const { formatted } = Util.tryParseAsNumberOrEmpty(value)
        row.numValue = formatted
      },
      onClipboardPaste: (row, value) => {
        const { formatted } = Util.tryParseAsNumberOrEmpty(value)
        row.numValue = formatted
      },
    },
  },
  {
    id: 'col2',
    header: 'enmValue',
    headerGroupName: '属性項目',
    render: row => row.enmValue?.t,
    onClipboardCopy: row => row.enmValue?.k ?? '',
    editSetting: ({
      type: 'combo',
      onStartEditing: row => row.enmValue,
      onEndEditing: (row, value) => {
        row.enmValue = value
      },
      onClipboardPaste: () => {
        console.warn('未実装')
      },
      comboProps: {
        getOptionText: opt => opt.t,
        getValueFromOption: opt => opt,
        getValueText: value => value.t,
        onFilter: async keyword => keyword
          ? DROPDOWN_OPTIONS.filter(x => x.k.includes(keyword))
          : [...DROPDOWN_OPTIONS],
      },
    } as Layout.ColumnEditSetting<DisplayData, RefInfo>) as Layout.ColumnEditSetting<DisplayData, unknown>,
  },
  {
    id: 'col3',
    header: 'refValue',
    render: row => row.refValue ? JSON.stringify(row.refValue) : '',
    onClipboardCopy: row => row.refValue?.k ?? '',
    editSetting: getRefValueEditSetting(),
  },
]
const getRefValueEditSetting = () => {
  const editSetting: Layout.ColumnEditSetting<DisplayData, RefInfo> = {
    type: 'async-combo',
    onStartEditing: row => row.refValue,
    onEndEditing: (row, value) => {
      row.refValue = value
    },
    onClipboardPaste: (row, value) => {
      try {
        const obj: RefInfo | undefined = JSON.parse(value)
        if (typeof obj?.k === 'string') row.refValue = obj
      } catch {
        // 何もしない
      }
    },
    comboProps: {
      onFilter: async keyword => keyword
        ? DROPDOWN_OPTIONS.filter(opt => opt.t.includes(keyword))
        : [...DROPDOWN_OPTIONS],
      getValueFromOption: opt => opt,
      getOptionText: opt => opt.t,
      getValueText: value => value.t,
    },
  }
  return editSetting as Layout.ColumnEditSetting<DisplayData, unknown>
}


// export default function () {

//   const [type, setType] = useState<'str' | 'num' | 'opt'>('str')
//   const [value, setValue] = useState<string>()
//   const [numValue, setNumValue] = useState<FormattedNumberString | DirtyValue>()
//   const [refValue, setRefValue] = useState<RefInfo | DirtyValue>()

//   const handleChange = useCallback((value: string | undefined) => {
//     if (type === 'str') {
//       setValue(value)
//       setNumValue(value)
//       setRefValue(value)
//     } else if (type === 'num') {
//       const { formatted } = tryParseAsNumberOrEmpty(value)
//       setValue(formatted)
//       setNumValue(formatted)
//       setRefValue(formatted)
//     } else {
//       const selected = DROPDOWN_OPTIONS.find(opt => opt.k === value)
//       setValue(value)
//       setNumValue(value)
//       setRefValue(selected ? { key: selected.k, item: selected } : value)
//     }
//   }, [type, setValue, setNumValue, setRefValue])

//   const onValidate: ValidationHandler | undefined = useMemo(() => {
//     return type === 'num' ? tryParseAsNumberOrEmpty : undefined
//   }, [type])

//   const dropdownBody: DropDownBody | undefined = useMemo(() => {
//     if (type !== 'opt') return undefined
//     return ({ focusRef }) => (
//       <ul ref={focusRef}>
//         {DROPDOWN_OPTIONS.map(({ k, t }) => (
//           <li key={k}>
//             {t}
//           </li>
//         ))}
//       </ul>)
//   }, [type])

//   return (
//     <div className="flex flex-col gap-2 justify-start items-start p-2">
//       <div className="flex gap-2">
//         <label><input type="radio" name="type" value="str" checked={type === 'str'} onChange={() => setType('str')} />文字列</label>
//         <label><input type="radio" name="type" value="num" checked={type === 'num'} onChange={() => setType('num')} />数値</label>
//         <label><input type="radio" name="type" value="opt" checked={type === 'opt'} onChange={() => setType('opt')} />選択</label>
//       </div>

//       {type !== 'opt' && (
//         <TextInputBase
//           value={value}
//           onChange={handleChange}
//           dropdownBody={dropdownBody}
//           onValidate={onValidate}
//         />
//       )}
//       {type === 'opt' && (
//         <ComboBoxBase
//           value={value}
//           onChange={handleChange}
//           options={DROPDOWN_OPTIONS}
//           emitValueSelector={x => x.k}
//           matchingKeySelectorFromEmitValue={x => x}
//           matchingKeySelectorFromOption={x => x.k}
//           textSelector={x => x.t}
//         />
//       )}

//       <table className="text-left">
//         <tbody>
//           <tr>
//             <th>type</th>
//             <td>{type}</td>
//           </tr>
//           <tr>
//             <th>value</th>
//             <td>{value}</td>
//           </tr>
//           <tr>
//             <th>numValue</th>
//             <td>{numValue}</td>
//           </tr>
//           <tr>
//             <th>refValue</th>
//             <td>{JSON.stringify(refValue)}</td>
//           </tr>
//         </tbody>
//       </table>
//     </div>
//   )
// }
